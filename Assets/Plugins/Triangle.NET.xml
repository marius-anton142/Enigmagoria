<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Triangle.NET</name>
    </assembly>
    <members>
        <member name="T:TriangleNet.Behavior">
            <summary>
            Controls the behavior of the meshing software.
            </summary>
        </member>
        <member name="M:TriangleNet.Behavior.#ctor(System.Boolean,System.Double)">
            <summary>
            Creates an instance of the Behavior class.
            </summary>
        </member>
        <member name="M:TriangleNet.Behavior.Update">
            <summary>
            Update quality options dependencies.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.NoExact">
            <summary>
            No exact arithmetic.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.Quality">
            <summary>
            Quality mesh generation.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.MinAngle">
            <summary>
            Minimum angle constraint.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.MaxAngle">
            <summary>
            Maximum angle constraint.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.MaxArea">
            <summary>
            Maximum area constraint.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.VarArea">
            <summary>
            Apply a maximum triangle area constraint.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.Poly">
            <summary>
            Input is a Planar Straight Line Graph.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.UserTest">
            <summary>
            Apply a user-defined triangle constraint.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.Exclude">
            <summary>
            Exclude triangles from being refined.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.Convex">
            <summary>
            Enclose the convex hull with segments.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.ConformingDelaunay">
            <summary>
            Conforming Delaunay (all triangles are truly Delaunay).
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.NoBisect">
            <summary>
            Suppresses boundary segment splitting.
            </summary>
            <remarks>
            0 = split segments
            1 = no new vertices on the boundary
            2 = prevent all segment splitting, including internal boundaries
            </remarks>
        </member>
        <member name="P:TriangleNet.Behavior.UseBoundaryMarkers">
            <summary>
            Compute boundary information.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.NoHoles">
            <summary>
            Ignores holes in polygons.
            </summary>
        </member>
        <member name="P:TriangleNet.Behavior.Jettison">
            <summary>
            Jettison unused vertices from output.
            </summary>
        </member>
        <member name="T:TriangleNet.Configuration">
            <summary>
            Configure advanced aspects of the library.
            </summary>
        </member>
        <member name="M:TriangleNet.Configuration.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Configuration" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Configuration.#ctor(System.Func{TriangleNet.IPredicates})">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Configuration" /> class.
            </summary>
            <param name="predicates">Factory method for <see cref="T:TriangleNet.IPredicates" />.</param>
        </member>
        <member name="M:TriangleNet.Configuration.#ctor(System.Func{TriangleNet.IPredicates},System.Func{TriangleNet.TrianglePool})">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Configuration" /> class.
            </summary>
            <param name="predicates">Factory method for <see cref="T:TriangleNet.IPredicates" />.</param>
            <param name="trianglePool">Factory method for <see cref="T:TriangleNet.TrianglePool" />.</param>
        </member>
        <member name="P:TriangleNet.Configuration.Predicates">
            <summary>
            Gets or sets the factory method for the <see cref="T:TriangleNet.IPredicates"/> implementation.
            </summary>
        </member>
        <member name="P:TriangleNet.Configuration.TrianglePool">
            <summary>
            Gets or sets the factory method for the <see cref="T:TriangleNet.TrianglePool"/>.
            </summary>
        </member>
        <member name="P:TriangleNet.Configuration.RandomSource">
            <summary>
            Gets or sets the factory method for a <see cref="T:System.Random"/> source.
            </summary>
        </member>
        <member name="T:TriangleNet.VertexType">
            <summary>
            The type of the mesh vertex.
            </summary>
        </member>
        <member name="T:TriangleNet.NodeNumbering">
            <summary>
            Node renumbering algorithms.
            </summary>
        </member>
        <member name="T:TriangleNet.LocateResult">
            <summary>
            Labels that signify the result of point location.
            </summary>
            <remarks>The result of a search indicates that the point falls in the 
            interior of a triangle, on an edge, on a vertex, or outside the mesh.
            </remarks>
        </member>
        <member name="T:TriangleNet.InsertVertexResult">
            <summary>
            Labels that signify the result of vertex insertion.
            </summary>
            <remarks>The result indicates that the vertex was inserted with complete 
            success, was inserted but encroaches upon a subsegment, was not inserted 
            because it lies on a segment, or was not inserted because another vertex 
            occupies the same location.
            </remarks>
        </member>
        <member name="T:TriangleNet.FindDirectionResult">
            <summary>
            Labels that signify the result of direction finding.
            </summary>
            <remarks>The result indicates that a segment connecting the two query 
            points falls within the direction triangle, along the left edge of the 
            direction triangle, or along the right edge of the direction triangle.
            </remarks>
        </member>
        <member name="T:TriangleNet.Geometry.Contour">
            <summary>
            Represents a contour of a polygon (outer boundary or internal holes).
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Contour.Points">
            <summary>
            Gets or sets the list of points making up the contour.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Contour.#ctor(System.Collections.Generic.IEnumerable{TriangleNet.Geometry.Vertex})">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Contour" /> class.
            </summary>
            <param name="points">The points that make up the contour.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Contour.#ctor(System.Collections.Generic.IEnumerable{TriangleNet.Geometry.Vertex},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Contour" /> class.
            </summary>
            <param name="points">The points that make up the contour.</param>
            <param name="marker">Contour marker.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Contour.#ctor(System.Collections.Generic.IEnumerable{TriangleNet.Geometry.Vertex},System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Contour" /> class.
            </summary>
            <param name="points">The points that make up the contour.</param>
            <param name="marker">Contour marker.</param>
            <param name="convex">The hole is convex.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Contour.GetSegments">
            <summary>
            Gets the list of segments of the contour.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Geometry.Contour.FindInteriorPoint(System.Int32,System.Double)">
            <summary>
            Try to find a point inside the contour.
            </summary>
            <param name="limit">The number of iterations on each segment (default = 5).</param>
            <param name="eps">Threshold for co-linear points (default = 2e-5).</param>
            <returns>Point inside the contour</returns>
            <exception cref="T:System.Exception">Throws if no point could be found.</exception>
            <remarks>
            For each corner (index i) of the contour, the 3 points with indices i-1, i and i+1
            are considered and a search on the line through the corner vertex is started (either
            on the bisecting line, or, if <see cref="M:TriangleNet.IPredicates.CounterClockwise(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point)"/> is less than
            eps, on the perpendicular line.
            A given number of points will be tested (limit), while the distance to the contour
            boundary will be reduced in each iteration (with a factor 1 / 2^i, i = 1 ... limit).
            </remarks>
        </member>
        <member name="M:TriangleNet.Geometry.Contour.IsPointInPolygon(TriangleNet.Geometry.Point,System.Collections.Generic.List{TriangleNet.Geometry.Vertex})">
            <summary>
            Return true if the given point is inside the polygon, or false if it is not.
            </summary>
            <param name="point">The point to check.</param>
            <param name="poly">The polygon (list of contour points).</param>
            <returns></returns>
            <remarks>
            WARNING: If the point is exactly on the edge of the polygon, then the function
            may return true or false.
            
            See http://alienryderflex.com/polygon/
            </remarks>
        </member>
        <member name="M:TriangleNet.Geometry.Contour.IsPointOnSegment(TriangleNet.Geometry.Point,System.Collections.Generic.List{TriangleNet.Geometry.Vertex},System.Double)">
            <summary>
            Work around IsPointInPolygon() failing for points on segments.
            </summary>
        </member>
        <member name="T:TriangleNet.Geometry.Edge">
            <summary>
            Represents a straight line segment in 2D space.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Edge.P0">
            <summary>
            Gets the first endpoints index.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Edge.P1">
            <summary>
            Gets the second endpoints index.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Edge.Label">
            <summary>
            Gets the segments boundary mark.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Edge.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Edge" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Edge.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Edge" /> class.
            </summary>
        </member>
        <member name="T:TriangleNet.Geometry.ExtensionMethods">
            <summary>
            Extension methods.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.ExtensionMethods.Triangulate(TriangleNet.Geometry.IPolygon)">
            <summary>
            Triangulates a polygon.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.ExtensionMethods.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.ConstraintOptions)">
            <summary>
            Triangulates a polygon, applying constraint options.
            </summary>
            <param name="polygon">Polygon instance.</param>
            <param name="options">Constraint options.</param>
        </member>
        <member name="M:TriangleNet.Geometry.ExtensionMethods.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.QualityOptions)">
            <summary>
            Triangulates a polygon, applying quality options.
            </summary>
            <param name="polygon">Polygon instance.</param>
            <param name="quality">Quality options.</param>
        </member>
        <member name="M:TriangleNet.Geometry.ExtensionMethods.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.ConstraintOptions,TriangleNet.Meshing.QualityOptions)">
            <summary>
            Triangulates a polygon, applying quality and constraint options.
            </summary>
            <param name="polygon">Polygon instance.</param>
            <param name="options">Constraint options.</param>
            <param name="quality">Quality options.</param>
        </member>
        <member name="M:TriangleNet.Geometry.ExtensionMethods.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.ConstraintOptions,TriangleNet.Meshing.QualityOptions,TriangleNet.Meshing.ITriangulator)">
            <summary>
            Triangulates a polygon, applying quality and constraint options.
            </summary>
            <param name="polygon">Polygon instance.</param>
            <param name="options">Constraint options.</param>
            <param name="quality">Quality options.</param>
            <param name="triangulator">The triangulation algorithm.</param>
        </member>
        <member name="M:TriangleNet.Geometry.ExtensionMethods.Contains(TriangleNet.Geometry.ITriangle,TriangleNet.Geometry.Point)">
            <summary>
            Test whether a given point lies inside a triangle or not.
            </summary>
            <param name="triangle">Triangle instance.</param>
            <param name="p">Point to locate.</param>
            <returns>True, if point is inside or on the edge of this triangle.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.ExtensionMethods.Contains(TriangleNet.Geometry.ITriangle,System.Double,System.Double)">
            <summary>
            Test whether a given point lies inside a triangle or not.
            </summary>
            <param name="triangle">Triangle instance.</param>
            <param name="x">Point to locate.</param>
            <param name="y">Point to locate.</param>
            <returns>True, if point is inside or on the edge of this triangle.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.ExtensionMethods.Bounds(TriangleNet.Geometry.ITriangle)">
            <summary>
            Returns the bounding box of the triangle.
            </summary>
            <param name="triangle">Triangle instance.</param>
            <returns></returns>
        </member>
        <member name="T:TriangleNet.Geometry.IEdge">
            <summary>
            Simple edge interface.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.IEdge.P0">
            <summary>
            Gets the first endpoints index.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.IEdge.P1">
            <summary>
            Gets the second endpoints index.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.IEdge.Label">
            <summary>
            Gets or sets a general-purpose label.
            </summary>
            <remarks>
            This is used for the segments boundary mark.
            </remarks>
        </member>
        <member name="T:TriangleNet.Geometry.IPolygon">
            <summary>
            Polygon interface.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.IPolygon.Points">
            <summary>
            Gets the vertices of the polygon.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.IPolygon.Segments">
            <summary>
            Gets the segments of the polygon.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.IPolygon.Holes">
            <summary>
            Gets a list of points defining the holes of the polygon.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.IPolygon.Regions">
            <summary>
            Gets a list of pointers defining the regions of the polygon.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.IPolygon.HasPointMarkers">
            <summary>
            Gets or sets a value indicating whether the vertices have marks or not.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.IPolygon.HasSegmentMarkers">
            <summary>
            Gets or sets a value indicating whether the segments have marks or not.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.IPolygon.Bounds">
            <summary>
            Compute the bounds of the polygon.
            </summary>
            <returns>Rectangle defining an axis-aligned bounding box.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.IPolygon.Add(TriangleNet.Geometry.Vertex)">
            <summary>
            Add a vertex to the polygon.
            </summary>
            <param name="vertex">The vertex to insert.</param>
        </member>
        <member name="M:TriangleNet.Geometry.IPolygon.Add(TriangleNet.Geometry.ISegment,System.Boolean)">
            <summary>
            Add a segment to the polygon.
            </summary>
            <param name="segment">The segment to insert.</param>
            <param name="insert">If true, both endpoints will be added to the points list.</param>
        </member>
        <member name="M:TriangleNet.Geometry.IPolygon.Add(TriangleNet.Geometry.ISegment,System.Int32)">
            <summary>
            Add a segment to the polygon.
            </summary>
            <param name="segment">The segment to insert.</param>
            <param name="index">The index of the segment endpoint to add to the points list (must be 0 or 1).</param>
        </member>
        <member name="M:TriangleNet.Geometry.IPolygon.Add(TriangleNet.Geometry.Contour,System.Int32)">
            <summary>
            Add a contour to the polygon.
            </summary>
            <param name="contour">The contour to insert.</param>
            <param name="regionlabel">label to ease finding contours in the created mesh.</param>
        </member>
        <member name="M:TriangleNet.Geometry.IPolygon.Add(TriangleNet.Geometry.Contour,System.Boolean)">
            <summary>
            Add a contour to the polygon.
            </summary>
            <param name="contour">The contour to insert.</param>
            <param name="hole">Treat contour as a hole.</param>
        </member>
        <member name="M:TriangleNet.Geometry.IPolygon.Add(TriangleNet.Geometry.Contour,TriangleNet.Geometry.Point)">
            <summary>
            Add a contour to the polygon.
            </summary>
            <param name="contour">The contour to insert.</param>
            <param name="hole">Point inside the contour, making it a hole.</param>
        </member>
        <member name="T:TriangleNet.Geometry.ISegment">
            <summary>
            Interface for segment geometry.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.ISegment.GetVertex(System.Int32)">
            <summary>
            Gets the vertex at given index.
            </summary>
            <param name="index">The local index (0 or 1).</param>
        </member>
        <member name="M:TriangleNet.Geometry.ISegment.GetTriangle(System.Int32)">
            <summary>
            Gets an adjoining triangle.
            </summary>
            <param name="index">The triangle index (0 or 1).</param>
        </member>
        <member name="T:TriangleNet.Geometry.ITriangle">
            <summary>
            Triangle interface.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.ITriangle.ID">
            <summary>
            Gets or sets the triangle ID.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.ITriangle.Label">
            <summary>
            Gets or sets a general-purpose label.
            </summary>
            <remarks>
            This is used for region information.
            </remarks>
        </member>
        <member name="P:TriangleNet.Geometry.ITriangle.Area">
            <summary>
            Gets or sets the triangle area constraint.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.ITriangle.GetVertex(System.Int32)">
            <summary>
            Gets the vertex at given index.
            </summary>
            <param name="index">The local index (0, 1 or 2).</param>
            <returns>The vertex.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.ITriangle.GetVertexID(System.Int32)">
            <summary>
            Gets the ID of the vertex at given index.
            </summary>
            <param name="index">The local index (0, 1 or 2).</param>
            <returns>The vertex ID.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.ITriangle.GetNeighbor(System.Int32)">
            <summary>
            Gets the neighbor triangle at given index.
            </summary>
            <param name="index">The local index (0, 1 or 2).</param>
            <returns>The neighbor triangle.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.ITriangle.GetNeighborID(System.Int32)">
            <summary>
            Gets the ID of the neighbor triangle at given index.
            </summary>
            <param name="index">The local index (0, 1 or 2).</param>
            <returns>The neighbor triangle ID.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.ITriangle.GetSegment(System.Int32)">
            <summary>
            Gets the segment at given index.
            </summary>
            <param name="index">The local index (0, 1 or 2).</param>
            <returns>The segment.</returns>
        </member>
        <member name="T:TriangleNet.Geometry.Point">
            <summary>
            Represents a 2D point.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Point.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Point" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Point.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Point" /> class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Point.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Point" /> class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="label">The point label.</param>
        </member>
        <member name="P:TriangleNet.Geometry.Point.ID">
            <summary>
            Gets or sets the vertex id.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Point.X">
            <summary>
            Gets or sets the vertex x coordinate.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Point.Y">
            <summary>
            Gets or sets the vertex y coordinate.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Point.Label">
            <summary>
            Gets or sets a general-purpose label.
            </summary>
            <remarks>
            This is used for the vertex boundary mark.
            </remarks>
        </member>
        <member name="M:TriangleNet.Geometry.Point.op_Equality(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Point.op_Inequality(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Point.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Point.Equals(TriangleNet.Geometry.Point)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Point.CompareTo(TriangleNet.Geometry.Point)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Point.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Geometry.Polygon">
            <summary>
            A polygon represented as a planar straight line graph.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Polygon.Points">
            <inheritdoc />
        </member>
        <member name="P:TriangleNet.Geometry.Polygon.Holes">
            <inheritdoc />
        </member>
        <member name="P:TriangleNet.Geometry.Polygon.Regions">
            <inheritdoc />
        </member>
        <member name="P:TriangleNet.Geometry.Polygon.Segments">
            <inheritdoc />
        </member>
        <member name="P:TriangleNet.Geometry.Polygon.HasPointMarkers">
            <inheritdoc />
        </member>
        <member name="P:TriangleNet.Geometry.Polygon.HasSegmentMarkers">
            <inheritdoc />
        </member>
        <member name="P:TriangleNet.Geometry.Polygon.Count">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Polygon" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Polygon" /> class.
            </summary>
            <param name="capacity">The default capacity for the points list.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Polygon" /> class.
            </summary>
            <param name="capacity">The default capacity for the points list.</param>
            <param name="markers">Use point and segment markers.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.Bounds">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.Add(TriangleNet.Geometry.Vertex)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.Add(TriangleNet.Geometry.ISegment,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.Add(TriangleNet.Geometry.ISegment,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.Add(TriangleNet.Geometry.Contour,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.Add(TriangleNet.Geometry.Contour,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Geometry.Polygon.Add(TriangleNet.Geometry.Contour,TriangleNet.Geometry.Point)">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Geometry.Rectangle">
            <summary>
            A simple rectangle class.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Rectangle" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.#ctor(TriangleNet.Geometry.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Rectangle" /> class.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Rectangle" /> class
            with predefined bounds.
            </summary>
            <param name="x">Minimum x value (left).</param>
            <param name="y">Minimum y value (bottom).</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
        </member>
        <member name="P:TriangleNet.Geometry.Rectangle.Left">
            <summary>
            Gets the minimum x value (left boundary).
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Rectangle.Right">
            <summary>
            Gets the maximum x value (right boundary).
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Rectangle.Bottom">
            <summary>
            Gets the minimum y value (bottom boundary).
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Rectangle.Top">
            <summary>
            Gets the maximum y value (top boundary).
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Rectangle.X">
            <summary>
            Gets the minimum x value (left boundary).
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Rectangle.Y">
            <summary>
            Gets the minimum y value (bottom boundary).
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Rectangle.Width">
            <summary>
            Gets the width of the rectangle.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Rectangle.Height">
            <summary>
            Gets the height of the rectangle.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.Resize(System.Double,System.Double)">
            <summary>
            Update bounds.
            </summary>
            <param name="dx">Add dx to left and right bounds.</param>
            <param name="dy">Add dy to top and bottom bounds.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.Expand(TriangleNet.Geometry.Point)">
            <summary>
            Expand rectangle to include given point.
            </summary>
            <param name="p">Point.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.Expand(System.Collections.Generic.IEnumerable{TriangleNet.Geometry.Point})">
            <summary>
            Expand rectangle to include a list of points.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.Expand(TriangleNet.Geometry.Rectangle)">
            <summary>
            Expand rectangle to include given rectangle.
            </summary>
            <param name="other">The other rectangle.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.Contains(System.Double,System.Double)">
            <summary>
            Check if given point is inside rectangle.
            </summary>
            <param name="x">Point to check.</param>
            <param name="y">Point to check.</param>
            <returns>Return true, if rectangle contains given point.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.Contains(TriangleNet.Geometry.Point)">
            <summary>
            Check if given point is inside rectangle.
            </summary>
            <param name="pt">Point to check.</param>
            <returns>Return true, if rectangle contains given point.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.Contains(TriangleNet.Geometry.Rectangle)">
            <summary>
            Check if this rectangle contains other rectangle.
            </summary>
            <param name="other">Rectangle to check.</param>
            <returns>Return true, if this rectangle contains given rectangle.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.Rectangle.Intersects(TriangleNet.Geometry.Rectangle)">
            <summary>
            Check if this rectangle intersects other rectangle.
            </summary>
            <param name="other">Rectangle to check.</param>
            <returns>Return true, if given rectangle intersects this rectangle.</returns>
        </member>
        <member name="T:TriangleNet.Geometry.RegionPointer">
            <summary>
            Pointer to a region in the mesh geometry. A region is a well-defined
            subset of the geometry (enclosed by subsegments).
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.RegionPointer.Area">
            <summary>
            Gets or sets a region area constraint.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.RegionPointer.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.RegionPointer" /> class.
            </summary>
            <param name="x">X coordinate of the region.</param>
            <param name="y">Y coordinate of the region.</param>
            <param name="id">Region id.</param>
        </member>
        <member name="M:TriangleNet.Geometry.RegionPointer.#ctor(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.RegionPointer" /> class.
            </summary>
            <param name="x">X coordinate of the region.</param>
            <param name="y">Y coordinate of the region.</param>
            <param name="id">Region id.</param>
            <param name="area">Area constraint.</param>
        </member>
        <member name="T:TriangleNet.Geometry.Segment">
            <summary>
            Represents a straight line segment in 2D space.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Segment.Label">
            <summary>
            Gets or sets the segments boundary mark.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Segment.P0">
            <summary>
            Gets the first endpoints index.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Segment.P1">
            <summary>
            Gets the second endpoints index.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Segment.#ctor(TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Segment" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Segment.#ctor(TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Segment" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Segment.GetVertex(System.Int32)">
            <summary>
            Gets the specified segment endpoint.
            </summary>
            <param name="index">The endpoint index (0 or 1).</param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Geometry.Segment.GetTriangle(System.Int32)">
            <summary>
            WARNING: not implemented.
            </summary>
        </member>
        <member name="T:TriangleNet.Geometry.Vertex">
            <summary>
            The vertex data structure.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Vertex.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Vertex" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Geometry.Vertex.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Vertex" /> class.
            </summary>
            <param name="x">The x coordinate of the vertex.</param>
            <param name="y">The y coordinate of the vertex.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Vertex.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Vertex" /> class.
            </summary>
            <param name="x">The x coordinate of the vertex.</param>
            <param name="y">The y coordinate of the vertex.</param>
            <param name="mark">The boundary mark.</param>
        </member>
        <member name="M:TriangleNet.Geometry.Vertex.#ctor(System.Double,System.Double,System.Int32,TriangleNet.VertexType)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Geometry.Vertex" /> class.
            </summary>
            <param name="x">The x coordinate of the vertex.</param>
            <param name="y">The y coordinate of the vertex.</param>
            <param name="mark">The boundary mark.</param>
            <param name="type">The vertex type.</param>
        </member>
        <member name="P:TriangleNet.Geometry.Vertex.Type">
            <summary>
            Gets the vertex type.
            </summary>
        </member>
        <member name="P:TriangleNet.Geometry.Vertex.Item(System.Int32)">
            <summary>
            Gets the specified coordinate of the vertex.
            </summary>
            <param name="i">Coordinate index.</param>
            <returns>X coordinate, if index is 0, Y coordinate, if index is 1.</returns>
        </member>
        <member name="M:TriangleNet.Geometry.Vertex.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.IO.DebugWriter">
            <summary>
            Writes a the current mesh into a text file.
            </summary>
            <remarks>
            File format:
            
            num_nodes
            id_1 nx ny mark
            ...
            id_n nx ny mark
            
            num_segs
            id_1 p1 p2 mark
            ...
            id_n p1 p2 mark
            
            num_tris
            id_1 p1 p2 p3 n1 n2 n3
            ...
            id_n p1 p2 p3 n1 n2 n3
            </remarks>
        </member>
        <member name="M:TriangleNet.IO.DebugWriter.Start(System.String)">
            <summary>
            Start a new session with given name.
            </summary>
            <param name="name">Name of the session (and output files).</param>
        </member>
        <member name="M:TriangleNet.IO.DebugWriter.Write(TriangleNet.Mesh,System.Boolean)">
            <summary>
            Write complete mesh to file.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.DebugWriter.Finish">
            <summary>
            Finish this session.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.FileProcessor.Read(System.String)">
            <summary>
            Read a file containing polygon geometry.
            </summary>
            <param name="filename">The path of the file to read.</param>
            <returns>An instance of the <see cref="T:TriangleNet.Geometry.IPolygon" /> class.</returns>
        </member>
        <member name="M:TriangleNet.IO.FileProcessor.Write(TriangleNet.Geometry.IPolygon,System.String)">
            <summary>
            Save a polygon geometry to disk.
            </summary>
            <param name="polygon">An instance of the <see cref="T:TriangleNet.Geometry.IPolygon" /> class.</param>
            <param name="filename">The path of the file to save.</param>
        </member>
        <member name="M:TriangleNet.IO.FileProcessor.Import(System.String)">
            <summary>
            Read a file containing a mesh.
            </summary>
            <param name="filename">The path of the file to read.</param>
            <returns>An instance of the <see cref="T:TriangleNet.Meshing.IMesh" /> interface.</returns>
        </member>
        <member name="M:TriangleNet.IO.FileProcessor.Write(TriangleNet.Meshing.IMesh,System.String)">
            <summary>
            Save a mesh to disk.
            </summary>
            <param name="mesh">An instance of the <see cref="T:TriangleNet.Meshing.IMesh" /> interface.</param>
            <param name="filename">The path of the file to save.</param>
        </member>
        <member name="T:TriangleNet.IO.IFileFormat">
            <summary>
            Interface used to indicate support for file formats in the <see cref="T:TriangleNet.IO.FileProcessor" />.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.IFileFormat.IsSupported(System.String)">
            <summary>
            Test whether the given file is supported.
            </summary>
            <param name="file">The file to read.</param>
            <returns>Returns true if the file can be read.</returns>
        </member>
        <member name="T:TriangleNet.IO.IMeshFormat">
            <summary>
            Interface for mesh I/O.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.IMeshFormat.Import(System.String)">
            <summary>
            Read a file containing a mesh.
            </summary>
            <param name="filename">The path of the file to read.</param>
            <returns>An instance of the <see cref="T:TriangleNet.Meshing.IMesh" /> interface.</returns>
        </member>
        <member name="M:TriangleNet.IO.IMeshFormat.Write(TriangleNet.Meshing.IMesh,System.String)">
            <summary>
            Save a mesh to disk.
            </summary>
            <param name="mesh">An instance of the <see cref="T:TriangleNet.Meshing.IMesh" /> interface.</param>
            <param name="filename">The path of the file to save.</param>
        </member>
        <member name="M:TriangleNet.IO.IMeshFormat.Write(TriangleNet.Meshing.IMesh,System.IO.Stream)">
            <summary>
            Save a mesh to a <see cref="T:System.IO.Stream" />.
            </summary>
            <param name="mesh">An instance of the <see cref="T:TriangleNet.Meshing.IMesh" /> interface.</param>
            <param name="stream">The stream to save to.</param>
        </member>
        <member name="T:TriangleNet.IO.InputTriangle">
            <summary>
            Simple triangle class for input.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.InputTriangle.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.IO.InputTriangle" /> class.
            </summary>
        </member>
        <member name="P:TriangleNet.IO.InputTriangle.ID">
            <inheritdoc/>
        </member>
        <member name="P:TriangleNet.IO.InputTriangle.Label">
            <inheritdoc/>
        </member>
        <member name="P:TriangleNet.IO.InputTriangle.Area">
            <inheritdoc/>
        </member>
        <member name="M:TriangleNet.IO.InputTriangle.GetVertex(System.Int32)">
            <summary>
            WARNING: not implemented.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.InputTriangle.GetVertexID(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TriangleNet.IO.InputTriangle.GetNeighbor(System.Int32)">
            <summary>
            WARNING: not implemented.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.InputTriangle.GetNeighborID(System.Int32)">
            <summary>
            WARNING: not implemented.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.InputTriangle.GetSegment(System.Int32)">
            <summary>
            WARNING: not implemented.
            </summary>
        </member>
        <member name="T:TriangleNet.IO.IPolygonFormat">
            <summary>
            Interface for geometry input.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.IPolygonFormat.Read(System.String)">
            <summary>
            Read a file containing polygon geometry.
            </summary>
            <param name="filename">The path of the file to read.</param>
            <returns>An instance of the <see cref="T:TriangleNet.Geometry.IPolygon" /> class.</returns>
        </member>
        <member name="M:TriangleNet.IO.IPolygonFormat.Write(TriangleNet.Geometry.IPolygon,System.String)">
            <summary>
            Save a polygon geometry to disk.
            </summary>
            <param name="polygon">An instance of the <see cref="T:TriangleNet.Geometry.IPolygon" /> class.</param>
            <param name="filename">The path of the file to save.</param>
        </member>
        <member name="M:TriangleNet.IO.IPolygonFormat.Write(TriangleNet.Geometry.IPolygon,System.IO.Stream)">
            <summary>
            Save a polygon geometry to a <see cref="T:System.IO.Stream" />.
            </summary>
            <param name="polygon">An instance of the <see cref="T:TriangleNet.Geometry.IPolygon" /> class.</param>
            <param name="stream">The stream to save to.</param>
        </member>
        <member name="T:TriangleNet.IO.TriangleFormat">
            <summary>
            Implements geometry and mesh file formats of the original Triangle project.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.TriangleFormat.IsSupported(System.String)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.IO.TriangleFormat.Import(System.String)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.IO.TriangleFormat.Write(TriangleNet.Meshing.IMesh,System.String)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.IO.TriangleFormat.Write(TriangleNet.Meshing.IMesh,System.IO.Stream)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.IO.TriangleFormat.Read(System.String)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.IO.TriangleFormat.Write(TriangleNet.Geometry.IPolygon,System.String)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.IO.TriangleFormat.Write(TriangleNet.Geometry.IPolygon,System.IO.Stream)">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.IO.TriangleReader">
            <summary>
            Helper methods for reading Triangle file formats.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadVertex(System.Collections.Generic.List{TriangleNet.Geometry.Vertex},System.Int32,System.String[],System.Int32,System.Int32)">
            <summary>
            Read vertex information of the given line.
            </summary>
            <param name="data">The input geometry.</param>
            <param name="index">The current vertex index.</param>
            <param name="line">The current line.</param>
            <param name="attributes">Number of point attributes</param>
            <param name="marks">Number of point markers (0 or 1)</param>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.Read(System.String,TriangleNet.Geometry.Polygon@)">
            <summary>
            Reads geometry information from .node or .poly files.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.Read(System.String,TriangleNet.Geometry.Polygon@,System.Collections.Generic.List{TriangleNet.Geometry.ITriangle}@)">
            <summary>
            Reads a mesh from .node, .poly or .ele files.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.Read(System.String)">
            <summary>
            Reads geometry information from .node or .poly files.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadNodeFile(System.String)">
            <summary>
            Read the vertices from a file, which may be a .node or .poly file.
            </summary>
            <param name="nodefilename"></param>
            <remarks>Will NOT read associated .ele by default.</remarks>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadNodeFile(System.String,System.Boolean)">
            <summary>
            Read the vertices from a file, which may be a .node or .poly file.
            </summary>
            <param name="nodefilename"></param>
            <param name="readElements"></param>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadPolyFile(System.String)">
            <summary>
            Read the vertices and segments from a .poly file.
            </summary>
            <param name="polyfilename"></param>
            <remarks>Will NOT read associated .ele by default.</remarks>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadPolyFile(System.String,System.Boolean)">
            <summary>
            Read the vertices and segments from a .poly file.
            </summary>
            <param name="polyfilename"></param>
            <param name="readElements">If true, look for an associated .ele file.</param>
            <remarks>Will NOT read associated .area by default.</remarks>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadPolyFile(System.String,System.Boolean,System.Boolean)">
            <summary>
            Read the vertices and segments from a .poly file.
            </summary>
            <param name="polyfilename"></param>
            <param name="readElements">If true, look for an associated .ele file.</param>
            <param name="readArea">If true, look for an associated .area file.</param>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadEleFile(System.String)">
            <summary>
            Read elements from an .ele file.
            </summary>
            <param name="elefilename">The file name.</param>
            <returns>A list of triangles.</returns>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadEleFile(System.String,System.Boolean)">
            <summary>
            Read the elements from an .ele file.
            </summary>
            <param name="elefilename"></param>
            <param name="readArea"></param>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadAreaFile(System.String,System.Int32)">
            <summary>
            Read the area constraints from an .area file.
            </summary>
            <param name="areafilename"></param>
            <param name="intriangles"></param>
        </member>
        <member name="M:TriangleNet.IO.TriangleReader.ReadEdgeFile(System.String,System.Int32)">
            <summary>
            Read an .edge file.
            </summary>
            <param name="edgeFile">The file name.</param>
            <param name="invertices">The number of input vertices (read from a .node or .poly file).</param>
            <returns>A List of edges.</returns>
        </member>
        <member name="T:TriangleNet.IO.TriangleWriter">
            <summary>
            Helper methods for writing Triangle file formats.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.Write(TriangleNet.Mesh,System.String)">
            <summary>
            Number the vertices and write them to a .node file.
            </summary>
            <param name="mesh"></param>
            <param name="filename"></param>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.WriteNodes(TriangleNet.Mesh,System.String)">
            <summary>
            Number the vertices and write them to a .node file.
            </summary>
            <param name="mesh"></param>
            <param name="filename"></param>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.WriteNodes(System.IO.StreamWriter,TriangleNet.Mesh)">
            <summary>
            Number the vertices and write them to a .node file.
            </summary>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.WriteNodes(System.IO.StreamWriter,System.Collections.Generic.IEnumerable{TriangleNet.Geometry.Vertex},System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Write the vertices to a stream.
            </summary>
            <param name="writer"></param>
            <param name="nodes"></param>
            <param name="markers"></param>
            <param name="attribs"></param>
            <param name="jettison"></param>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.WriteElements(TriangleNet.Mesh,System.String)">
            <summary>
            Write the triangles to an .ele file.
            </summary>
            <param name="mesh"></param>
            <param name="filename"></param>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.WritePoly(TriangleNet.Geometry.IPolygon,System.String)">
            <summary>
            Write the segments and holes to a .poly file.
            </summary>
            <param name="polygon">Data source.</param>
            <param name="filename">File name.</param>
            <remarks>If the nodes should not be written into this file, 
            make sure a .node file was written before, so that the nodes 
            are numbered right.</remarks>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.WritePoly(TriangleNet.Mesh,System.String)">
            <summary>
            Write the segments and holes to a .poly file.
            </summary>
            <param name="mesh"></param>
            <param name="filename"></param>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.WritePoly(TriangleNet.Mesh,System.String,System.Boolean)">
            <summary>
            Write the segments and holes to a .poly file.
            </summary>
            <param name="mesh">Data source.</param>
            <param name="filename">File name.</param>
            <param name="writeNodes">Write nodes into this file.</param>
            <remarks>If the nodes should not be written into this file, 
            make sure a .node file was written before, so that the nodes 
            are numbered right.</remarks>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.WriteEdges(TriangleNet.Mesh,System.String)">
            <summary>
            Write the edges to an .edge file.
            </summary>
            <param name="mesh"></param>
            <param name="filename"></param>
        </member>
        <member name="M:TriangleNet.IO.TriangleWriter.WriteNeighbors(TriangleNet.Mesh,System.String)">
            <summary>
            Write the triangle neighbors to a .neigh file.
            </summary>
            <param name="mesh"></param>
            <param name="filename"></param>
            <remarks>WARNING: Be sure WriteElements has been called before, 
            so the elements are numbered right!</remarks>
        </member>
        <member name="T:TriangleNet.IPredicates">
            <summary>
            Geometric predicates interface.
            </summary>
        </member>
        <member name="M:TriangleNet.IPredicates.CounterClockwise(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point)">
            <summary>
            Check, if the three points appear in counterclockwise order. The result is 
            also a rough approximation of twice the signed area of the triangle defined 
            by the three points.
            </summary>
            <param name="a">Point a.</param>
            <param name="b">Point b.</param>
            <param name="c">Point c.</param>
            <returns>Return a positive value if the points pa, pb, and pc occur in 
            counterclockwise order; a negative value if they occur in clockwise order; 
            and zero if they are collinear.</returns>
        </member>
        <member name="M:TriangleNet.IPredicates.InCircle(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point)">
            <summary>
            Check if the point pd lies inside the circle passing through pa, pb, and pc. The 
            points pa, pb, and pc must be in counterclockwise order, or the sign of the result 
            will be reversed.
            </summary>
            <param name="a">Point a.</param>
            <param name="b">Point b.</param>
            <param name="c">Point c.</param>
            <param name="p">Point d.</param>
            <returns>Return a positive value if the point pd lies inside the circle passing through 
            pa, pb, and pc; a negative value if it lies outside; and zero if the four points 
            are cocircular.</returns>
        </member>
        <member name="M:TriangleNet.IPredicates.FindCircumcenter(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,System.Double@,System.Double@)">
            <summary>
            Find the circumcenter of a triangle.
            </summary>
            <param name="org">Triangle point.</param>
            <param name="dest">Triangle point.</param>
            <param name="apex">Triangle point.</param>
            <param name="xi">Relative coordinate of new location.</param>
            <param name="eta">Relative coordinate of new location.</param>
            <returns>Coordinates of the circumcenter</returns>
            <remarks>
            The result is returned both in terms of x-y coordinates and xi-eta
            (barycentric) coordinates. The xi-eta coordinate system is defined in
            terms of the triangle: the origin of the triangle is the origin of the
            coordinate system; the destination of the triangle is one unit along the
            xi axis; and the apex of the triangle is one unit along the eta axis.
            This procedure also returns the square of the length of the triangle's
            shortest edge.
            </remarks>
        </member>
        <member name="M:TriangleNet.IPredicates.FindCircumcenter(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,System.Double@,System.Double@,System.Double)">
            <summary>
            Find the circumcenter of a triangle.
            </summary>
            <param name="org">Triangle point.</param>
            <param name="dest">Triangle point.</param>
            <param name="apex">Triangle point.</param>
            <param name="xi">Relative coordinate of new location.</param>
            <param name="eta">Relative coordinate of new location.</param>
            <param name="offconstant">Off-center constant.</param>
            <returns>Coordinates of the circumcenter (or off-center)</returns>
        </member>
        <member name="T:TriangleNet.LogLevel">
            <summary>
            The log level.
            </summary>
        </member>
        <member name="T:TriangleNet.LogItem">
            <summary>
            Represents an item stored in the log.
            </summary>
        </member>
        <member name="P:TriangleNet.LogItem.Time">
            <summary>
            Gets the <see cref="T:System.DateTime"/> the item was logged.
            </summary>
        </member>
        <member name="P:TriangleNet.LogItem.Level">
            <summary>
            Gets the <see cref="T:TriangleNet.LogLevel"/>.
            </summary>
        </member>
        <member name="P:TriangleNet.LogItem.Message">
            <summary>
            Gets the log message.
            </summary>
        </member>
        <member name="P:TriangleNet.LogItem.Details">
            <summary>
            Gets further details of the log message.
            </summary>
        </member>
        <member name="M:TriangleNet.LogItem.#ctor(TriangleNet.LogLevel,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:TriangleNet.LogItem"/> class.
            </summary>
            <param name="level">The log level.</param>
            <param name="message">The log message.</param>
        </member>
        <member name="M:TriangleNet.LogItem.#ctor(TriangleNet.LogLevel,System.String,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:TriangleNet.LogItem"/> class.
            </summary>
            <param name="level">The log level.</param>
            <param name="message">The log message.</param>
            <param name="details">The message details.</param>
        </member>
        <member name="T:TriangleNet.Log">
            <summary>
            A simple logger, which logs messages to a List.
            </summary>
        </member>
        <member name="P:TriangleNet.Log.Verbose">
            <summary>
            Log detailed information.
            </summary>
        </member>
        <member name="P:TriangleNet.Log.Data">
            <summary>
            Gets all log messages.
            </summary>
        </member>
        <member name="P:TriangleNet.Log.Instance">
            <summary>
            Gets the <see cref="T:TriangleNet.Log"/> instance.
            </summary>
        </member>
        <member name="M:TriangleNet.Log.Add(TriangleNet.LogItem)">
            <summary>
            Adds a <see cref="T:TriangleNet.LogItem"/> to the log.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:TriangleNet.Log.Clear">
            <summary>
            Clear all messages from the log.
            </summary>
        </member>
        <member name="M:TriangleNet.Log.Info(System.String)">
            <summary>
            Log info message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:TriangleNet.Log.Warning(System.String,System.String)">
            <summary>
            Log warning message.
            </summary>
            <param name="message">The message.</param>
            <param name="details">Message details, for example the code location where the error occurred (class, method).</param>
        </member>
        <member name="M:TriangleNet.Log.Error(System.String,System.String)">
            <summary>
            Log error message.
            </summary>
            <param name="message">The message.</param>
            <param name="details">Message details, for example the code location where the error occurred (class, method).</param>
        </member>
        <member name="T:TriangleNet.Mesh">
            <summary>
            Mesh data structure.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.Bounds">
            <summary>
            Gets the mesh bounding box.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.Vertices">
            <summary>
            Gets the mesh vertices.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.Holes">
            <summary>
            Gets the mesh holes.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.Triangles">
            <summary>
            Gets the mesh triangles.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.Segments">
            <summary>
            Gets the mesh segments.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.Edges">
            <summary>
            Gets the mesh edges.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.NumberOfInputPoints">
            <summary>
            Gets the number of input vertices.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.NumberOfEdges">
            <summary>
            Gets the number of mesh edges.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.IsPolygon">
            <summary>
            Indicates whether the input is a PSLG or a point set.
            </summary>
        </member>
        <member name="P:TriangleNet.Mesh.CurrentNumbering">
            <summary>
            Gets the current node numbering.
            </summary>
        </member>
        <member name="M:TriangleNet.Mesh.#ctor(TriangleNet.Configuration,System.Collections.Generic.IList{TriangleNet.Geometry.Vertex})">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Mesh" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Mesh.Refine(TriangleNet.Meshing.QualityOptions,System.Boolean)">
            <summary>
            Refine the mesh to match given quality options.
            </summary>
            <param name="quality">The quality constraints.</param>
            <param name="delaunay">A value indicating, whether the refined mesh should be Conforming Delaunay.</param>
        </member>
        <member name="M:TriangleNet.Mesh.Renumber">
            <summary>
            Renumber vertex and triangle id's.
            </summary>
        </member>
        <member name="M:TriangleNet.Mesh.Renumber(TriangleNet.NodeNumbering)">
            <summary>
            Renumber vertex and triangle id's.
            </summary>
        </member>
        <member name="M:TriangleNet.Mesh.SetQualityMesher(TriangleNet.Meshing.QualityMesher)">
            <summary>
            Set QualityMesher for mesh refinement.
            </summary>
            <param name="qmesher"></param>
        </member>
        <member name="M:TriangleNet.Mesh.Reset">
            <summary>
            Reset the mesh triangulation state.
            </summary>
        </member>
        <member name="M:TriangleNet.Mesh.TransferNodes(System.Collections.Generic.IList{TriangleNet.Geometry.Vertex})">
            <summary>
            Read the vertices from memory.
            </summary>
            <param name="points">The input data.</param>
        </member>
        <member name="M:TriangleNet.Mesh.MakeVertexMap">
            <summary>
            Construct a mapping from vertices to triangles to improve the speed of 
            point location for segment insertion.
            </summary>
            <remarks>
            Traverses all the triangles, and provides each corner of each triangle
            with a pointer to that triangle. Of course, pointers will be overwritten
            by other pointers because (almost) each vertex is a corner of several
            triangles, but in the end every vertex will point to some triangle
            that contains it.
            </remarks>
        </member>
        <member name="M:TriangleNet.Mesh.MakeTriangle(TriangleNet.Topology.Otri@)">
            <summary>
            Create a new triangle with orientation zero.
            </summary>
            <param name="newotri">Reference to the new triangle.</param>
        </member>
        <member name="M:TriangleNet.Mesh.MakeSegment(TriangleNet.Topology.Osub@)">
            <summary>
            Create a new subsegment with orientation zero.
            </summary>
            <param name="newsubseg">Reference to the new subseg.</param>
        </member>
        <member name="M:TriangleNet.Mesh.InsertVertex(TriangleNet.Geometry.Vertex,TriangleNet.Topology.Otri@,TriangleNet.Topology.Osub@,System.Boolean,System.Boolean)">
             <summary>
             Insert a vertex into a Delaunay triangulation, performing flips as necessary 
             to maintain the Delaunay property.
             </summary>
             <param name="newvertex">The point to be inserted.</param>
             <param name="searchtri">The triangle to start the search.</param>
             <param name="splitseg">Segment to split.</param>
             <param name="segmentflaws">Check for creation of encroached subsegments.</param>
             <param name="triflaws">Check for creation of bad quality triangles.</param>
             <returns>If a duplicate vertex or violated segment does not prevent the 
             vertex from being inserted, the return value will be ENCROACHINGVERTEX if 
             the vertex encroaches upon a subsegment (and checking is enabled), or
             SUCCESSFULVERTEX otherwise. In either case, 'searchtri' is set to a handle
             whose origin is the newly inserted vertex.</returns>
             <remarks>
             The point 'newvertex' is located. If 'searchtri.triangle' is not NULL,
             the search for the containing triangle begins from 'searchtri'.  If
             'searchtri.triangle' is NULL, a full point location procedure is called.
             If 'insertvertex' is found inside a triangle, the triangle is split into
             three; if 'insertvertex' lies on an edge, the edge is split in two,
             thereby splitting the two adjacent triangles into four. Edge flips are
             used to restore the Delaunay property. If 'insertvertex' lies on an
             existing vertex, no action is taken, and the value DUPLICATEVERTEX is
             returned. On return, 'searchtri' is set to a handle whose origin is the
             existing vertex.
            
             InsertVertex() does not use flip() for reasons of speed; some
             information can be reused from edge flip to edge flip, like the
             locations of subsegments.
             
             Param 'splitseg': Normally, the parameter 'splitseg' is set to NULL, 
             implying that no subsegment should be split. In this case, if 'insertvertex' 
             is found to lie on a segment, no action is taken, and the value VIOLATINGVERTEX 
             is returned. On return, 'searchtri' is set to a handle whose primary edge is the 
             violated subsegment.
             If the calling routine wishes to split a subsegment by inserting a vertex in it, 
             the parameter 'splitseg' should be that subsegment. In this case, 'searchtri' 
             MUST be the triangle handle reached by pivoting from that subsegment; no point 
             location is done.
             
             Param 'segmentflaws': Flags that indicate whether or not there should
             be checks for the creation of encroached subsegments. If a newly inserted 
             vertex encroaches upon subsegments, these subsegments are added to the list 
             of subsegments to be split if 'segmentflaws' is set.
             
             Param 'triflaws': Flags that indicate whether or not there should be
             checks for the creation of bad quality triangles. If bad triangles are 
             created, these are added to the queue if 'triflaws' is set.
             </remarks>
        </member>
        <member name="M:TriangleNet.Mesh.InsertSubseg(TriangleNet.Topology.Otri@,System.Int32)">
            <summary>
            Create a new subsegment and inserts it between two triangles. Its 
            vertices are properly initialized.
            </summary>
            <param name="tri">The new subsegment is inserted at the edge 
            described by this handle.</param>
            <param name="subsegmark">The marker 'subsegmark' is applied to the 
            subsegment and, if appropriate, its vertices.</param>
        </member>
        <member name="M:TriangleNet.Mesh.Flip(TriangleNet.Topology.Otri@)">
             <summary>
             Transform two triangles to two different triangles by flipping an edge 
             counterclockwise within a quadrilateral.
             </summary>
             <param name="flipedge">Handle to the edge that will be flipped.</param>
             <remarks>Imagine the original triangles, abc and bad, oriented so that the
             shared edge ab lies in a horizontal plane, with the vertex b on the left
             and the vertex a on the right. The vertex c lies below the edge, and
             the vertex d lies above the edge. The 'flipedge' handle holds the edge
             ab of triangle abc, and is directed left, from vertex a to vertex b.
            
             The triangles abc and bad are deleted and replaced by the triangles cdb
             and dca.  The triangles that represent abc and bad are NOT deallocated;
             they are reused for dca and cdb, respectively.  Hence, any handles that
             may have held the original triangles are still valid, although not
             directed as they were before.
            
             Upon completion of this routine, the 'flipedge' handle holds the edge
             dc of triangle dca, and is directed down, from vertex d to vertex c.
             (Hence, the two triangles have rotated counterclockwise.)
            
             WARNING:  This transformation is geometrically valid only if the
             quadrilateral adbc is convex.  Furthermore, this transformation is
             valid only if there is not a subsegment between the triangles abc and
             bad.  This routine does not check either of these preconditions, and
             it is the responsibility of the calling routine to ensure that they are
             met.  If they are not, the streets shall be filled with wailing and
             gnashing of teeth.
             
             Terminology
            
             A "local transformation" replaces a small set of triangles with another
             set of triangles.  This may or may not involve inserting or deleting a
             vertex.
            
             The term "casing" is used to describe the set of triangles that are
             attached to the triangles being transformed, but are not transformed
             themselves.  Think of the casing as a fixed hollow structure inside
             which all the action happens.  A "casing" is only defined relative to
             a single transformation; each occurrence of a transformation will
             involve a different casing.
             </remarks>
        </member>
        <member name="M:TriangleNet.Mesh.Unflip(TriangleNet.Topology.Otri@)">
             <summary>
             Transform two triangles to two different triangles by flipping an edge 
             clockwise within a quadrilateral. Reverses the flip() operation so that 
             the data structures representing the triangles are back where they were 
             before the flip().
             </summary>
             <param name="flipedge"></param>
             <remarks>
             See above Flip() remarks for more information.
            
             Upon completion of this routine, the 'flipedge' handle holds the edge
             cd of triangle cdb, and is directed up, from vertex c to vertex d.
             (Hence, the two triangles have rotated clockwise.)
             </remarks>
        </member>
        <member name="M:TriangleNet.Mesh.TriangulatePolygon(TriangleNet.Topology.Otri,TriangleNet.Topology.Otri,System.Int32,System.Boolean,System.Boolean)">
             <summary>
             Find the Delaunay triangulation of a polygon that has a certain "nice" shape. 
             This includes the polygons that result from deletion of a vertex or insertion 
             of a segment.
             </summary>
             <param name="firstedge">The primary edge of the first triangle.</param>
             <param name="lastedge">The primary edge of the last triangle.</param>
             <param name="edgecount">The number of sides of the polygon, including its 
             base.</param>
             <param name="doflip">A flag, wether to perform the last flip.</param>
             <param name="triflaws">A flag that determines whether the new triangles should 
             be tested for quality, and enqueued if they are bad.</param>
             <remarks>
             This is a conceptually difficult routine. The starting assumption is
             that we have a polygon with n sides. n - 1 of these sides are currently
             represented as edges in the mesh. One side, called the "base", need not
             be.
            
             Inside the polygon is a structure I call a "fan", consisting of n - 1
             triangles that share a common origin. For each of these triangles, the
             edge opposite the origin is one of the sides of the polygon. The
             primary edge of each triangle is the edge directed from the origin to
             the destination; note that this is not the same edge that is a side of
             the polygon. 'firstedge' is the primary edge of the first triangle.
             From there, the triangles follow in counterclockwise order about the
             polygon, until 'lastedge', the primary edge of the last triangle.
             'firstedge' and 'lastedge' are probably connected to other triangles
             beyond the extremes of the fan, but their identity is not important, as
             long as the fan remains connected to them.
            
             Imagine the polygon oriented so that its base is at the bottom.  This
             puts 'firstedge' on the far right, and 'lastedge' on the far left.
             The right vertex of the base is the destination of 'firstedge', and the
             left vertex of the base is the apex of 'lastedge'.
            
             The challenge now is to find the right sequence of edge flips to
             transform the fan into a Delaunay triangulation of the polygon.  Each
             edge flip effectively removes one triangle from the fan, committing it
             to the polygon.  The resulting polygon has one fewer edge. If 'doflip'
             is set, the final flip will be performed, resulting in a fan of one
             (useless?) triangle. If 'doflip' is not set, the final flip is not
             performed, resulting in a fan of two triangles, and an unfinished
             triangular polygon that is not yet filled out with a single triangle.
             On completion of the routine, 'lastedge' is the last remaining triangle,
             or the leftmost of the last two.
            
             Although the flips are performed in the order described above, the
             decisions about what flips to perform are made in precisely the reverse
             order. The recursive triangulatepolygon() procedure makes a decision,
             uses up to two recursive calls to triangulate the "subproblems"
             (polygons with fewer edges), and then performs an edge flip.
            
             The "decision" it makes is which vertex of the polygon should be
             connected to the base. This decision is made by testing every possible
             vertex.  Once the best vertex is found, the two edges that connect this
             vertex to the base become the bases for two smaller polygons. These
             are triangulated recursively. Unfortunately, this approach can take
             O(n^2) time not only in the worst case, but in many common cases. It's
             rarely a big deal for vertex deletion, where n is rarely larger than
             ten, but it could be a big deal for segment insertion, especially if
             there's a lot of long segments that each cut many triangles. I ought to
             code a faster algorithm some day.
             </remarks>
        </member>
        <member name="M:TriangleNet.Mesh.DeleteVertex(TriangleNet.Topology.Otri@)">
             <summary>
             Delete a vertex from a Delaunay triangulation, ensuring that the 
             triangulation remains Delaunay.
             </summary>
             <param name="deltri"></param>
             <remarks>The origin of 'deltri' is deleted. The union of the triangles 
             adjacent to this vertex is a polygon, for which the Delaunay triangulation 
             is found. Two triangles are removed from the mesh.
            
             Only interior vertices that do not lie on segments or boundaries 
             may be deleted.
             </remarks>
        </member>
        <member name="M:TriangleNet.Mesh.UndoVertex">
            <summary>
            Undo the most recent vertex insertion.
            </summary>
            <remarks>
            Walks through the list of transformations (flips and a vertex insertion)
            in the reverse of the order in which they were done, and undoes them.
            The inserted vertex is removed from the triangulation and deallocated.
            Two triangles (possibly just one) are also deallocated.
            </remarks>
        </member>
        <member name="M:TriangleNet.Mesh.TriangleDealloc(TriangleNet.Topology.Triangle)">
            <summary>
            Deallocate space for a triangle, marking it dead.
            </summary>
            <param name="dyingtriangle"></param>
        </member>
        <member name="M:TriangleNet.Mesh.VertexDealloc(TriangleNet.Geometry.Vertex)">
            <summary>
            Deallocate space for a vertex, marking it dead.
            </summary>
            <param name="dyingvertex"></param>
        </member>
        <member name="M:TriangleNet.Mesh.SubsegDealloc(TriangleNet.Topology.SubSegment)">
            <summary>
            Deallocate space for a subsegment, marking it dead.
            </summary>
            <param name="dyingsubseg"></param>
        </member>
        <member name="T:TriangleNet.Meshing.Algorithm.Dwyer">
             <summary>
             Builds a delaunay triangulation using the divide-and-conquer algorithm.
             </summary>
             <remarks>
             The divide-and-conquer bounding box
            
             I originally implemented the divide-and-conquer and incremental Delaunay
             triangulations using the edge-based data structure presented by Guibas
             and Stolfi. Switching to a triangle-based data structure doubled the
             speed. However, I had to think of a few extra tricks to maintain the
             elegance of the original algorithms.
            
             The "bounding box" used by my variant of the divide-and-conquer
             algorithm uses one triangle for each edge of the convex hull of the
             triangulation. These bounding triangles all share a common apical
             vertex, which is represented by NULL and which represents nothing.
             The bounding triangles are linked in a circular fan about this NULL
             vertex, and the edges on the convex hull of the triangulation appear
             opposite the NULL vertex. You might find it easiest to imagine that
             the NULL vertex is a point in 3D space behind the center of the
             triangulation, and that the bounding triangles form a sort of cone.
            
             This bounding box makes it easy to represent degenerate cases. For
             instance, the triangulation of two vertices is a single edge. This edge
             is represented by two bounding box triangles, one on each "side" of the
             edge. These triangles are also linked together in a fan about the NULL
             vertex.
            
             The bounding box also makes it easy to traverse the convex hull, as the
             divide-and-conquer algorithm needs to do.
             </remarks>
        </member>
        <member name="F:TriangleNet.Meshing.Algorithm.Dwyer.UseDwyer">
            <summary>
            Gets or sets a value indicating whether to use alternating cuts (default = true).
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Algorithm.Dwyer.Triangulate(System.Collections.Generic.IList{TriangleNet.Geometry.Vertex},TriangleNet.Configuration)">
            <summary>
            Compute a Delaunay triangulation by the divide-and-conquer method.
            </summary>
            <returns></returns>
            <remarks>
            Sorts the vertices, calls a recursive procedure to triangulate them, and
            removes the bounding box, setting boundary markers as appropriate.
            </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.Algorithm.Dwyer.MergeHulls(TriangleNet.Topology.Otri@,TriangleNet.Topology.Otri@,TriangleNet.Topology.Otri@,TriangleNet.Topology.Otri@,System.Int32)">
             <summary>
             Merge two adjacent Delaunay triangulations into a single Delaunay triangulation.
             </summary>
             <param name="farleft">Bounding triangles of the left triangulation.</param>
             <param name="innerleft">Bounding triangles of the left triangulation.</param>
             <param name="innerright">Bounding triangles of the right triangulation.</param>
             <param name="farright">Bounding triangles of the right triangulation.</param>
             <param name="axis"></param>
             <remarks>
             This is similar to the algorithm given by Guibas and Stolfi, but uses
             a triangle-based, rather than edge-based, data structure.
            
             The algorithm walks up the gap between the two triangulations, knitting
             them together.  As they are merged, some of their bounding triangles
             are converted into real triangles of the triangulation.  The procedure
             pulls each hull's bounding triangles apart, then knits them together
             like the teeth of two gears.  The Delaunay property determines, at each
             step, whether the next "tooth" is a bounding triangle of the left hull
             or the right.  When a bounding triangle becomes real, its apex is
             changed from NULL to a real vertex.
            
             Only two new triangles need to be allocated.  These become new bounding
             triangles at the top and bottom of the seam.  They are used to connect
             the remaining bounding triangles (those that have not been converted
             into real triangles) into a single fan.
            
             On entry, 'farleft' and 'innerleft' are bounding triangles of the left
             triangulation.  The origin of 'farleft' is the leftmost vertex, and
             the destination of 'innerleft' is the rightmost vertex of the
             triangulation.  Similarly, 'innerright' and 'farright' are bounding
             triangles of the right triangulation.  The origin of 'innerright' and
             destination of 'farright' are the leftmost and rightmost vertices.
            
             On completion, the origin of 'farleft' is the leftmost vertex of the
             merged triangulation, and the destination of 'farright' is the rightmost
             vertex.
             </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.Algorithm.Dwyer.DivconqRecurse(System.Int32,System.Int32,System.Int32,TriangleNet.Topology.Otri@,TriangleNet.Topology.Otri@)">
             <summary>
             Recursively form a Delaunay triangulation by the divide-and-conquer method.
             </summary>
             <param name="left"></param>
             <param name="right"></param>
             <param name="axis"></param>
             <param name="farleft"></param>
             <param name="farright"></param>
             <remarks>
             Recursively breaks down the problem into smaller pieces, which are
             knitted together by mergehulls(). The base cases (problems of two or
             three vertices) are handled specially here.
            
             On completion, 'farleft' and 'farright' are bounding triangles such that
             the origin of 'farleft' is the leftmost vertex (breaking ties by
             choosing the highest leftmost vertex), and the destination of
             'farright' is the rightmost vertex (breaking ties by choosing the
             lowest rightmost vertex).
             </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.Algorithm.Dwyer.RemoveGhosts(TriangleNet.Topology.Otri@)">
            <summary>
            Removes ghost triangles.
            </summary>
            <param name="startghost"></param>
            <returns>Number of vertices on the hull.</returns>
        </member>
        <member name="T:TriangleNet.Meshing.Algorithm.Incremental">
            <summary>
            Builds a delaunay triangulation using the incremental algorithm.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Algorithm.Incremental.Triangulate(System.Collections.Generic.IList{TriangleNet.Geometry.Vertex},TriangleNet.Configuration)">
            <summary>
            Compute a Delaunay triangulation by incrementally inserting vertices.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Meshing.Algorithm.Incremental.GetBoundingBox">
            <summary>
            Form an "infinite" bounding triangle to insert vertices into.
            </summary>
            <remarks>
            The vertices at "infinity" are assigned finite coordinates, which are
            used by the point location routines, but (mostly) ignored by the
            Delaunay edge flip routines.
            </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.Algorithm.Incremental.RemoveBox">
            <summary>
            Remove the "infinite" bounding triangle, setting boundary markers as appropriate.
            </summary>
            <returns>Returns the number of edges on the convex hull of the triangulation.</returns>
            <remarks>
            The triangular bounding box has three boundary triangles (one for each
            side of the bounding box), and a bunch of triangles fanning out from
            the three bounding box vertices (one triangle for each edge of the
            convex hull of the inner mesh).  This routine removes these triangles.
            </remarks>
        </member>
        <member name="T:TriangleNet.Meshing.Algorithm.SweepLine">
            <summary>
            Builds a delaunay triangulation using the sweepline algorithm.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Algorithm.SweepLine.Triangulate(System.Collections.Generic.IList{TriangleNet.Geometry.Vertex},TriangleNet.Configuration)">
            <summary>
            Compute a Delaunay triangulation by the sweepline method.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Algorithm.SweepLine.RemoveGhosts(TriangleNet.Topology.Otri@)">
            <summary>
            Removes ghost triangles.
            </summary>
            <param name="startghost"></param>
            <returns>Number of vertices on the hull.</returns>
        </member>
        <member name="T:TriangleNet.Meshing.Algorithm.SweepLine.SweepEvent">
            <summary>
            A node in a heap used to store events for the sweepline Delaunay algorithm.
            </summary>
            <remarks>
            Only used in the sweepline algorithm.
            
            Nodes do not point directly to their parents or children in the heap. Instead, each
            node knows its position in the heap, and can look up its parent and children in a
            separate array. To distinguish site events from circle events, all circle events are
            given an invalid (smaller than 'xmin') x-coordinate 'xkey'.
            </remarks>
        </member>
        <member name="T:TriangleNet.Meshing.Algorithm.SweepLine.SweepEventVertex">
            <summary>
            Introducing a new class which aggregates a sweep event is the easiest way
            to handle the pointer magic of the original code (casting a sweep event 
            to vertex etc.).
            </summary>
        </member>
        <member name="T:TriangleNet.Meshing.Algorithm.SweepLine.SplayNode">
            <summary>
            A node in the splay tree.
            </summary>
            <remarks>
            Only used in the sweepline algorithm.
            
            Each node holds an oriented ghost triangle that represents a boundary edge
            of the growing triangulation. When a circle event covers two boundary edges
            with a triangle, so that they are no longer boundary edges, those edges are
            not immediately deleted from the tree; rather, they are lazily deleted when
            they are next encountered. (Since only a random sample of boundary edges are
            kept in the tree, lazy deletion is faster.) 'keydest' is used to verify that
            a triangle is still the same as when it entered the splay tree; if it has
            been rotated (due to a circle event), it no longer represents a boundary
            edge and should be deleted.
            </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.Apply(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.ConstraintOptions)">
            <summary>
            Insert segments into the mesh.
            </summary>
            <param name="input">The polygon.</param>
            <param name="options">Constraint options.</param>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.CarveHoles">
            <summary>
            Find the holes and infect them. Find the area constraints and infect 
            them. Infect the convex hull. Spread the infection and kill triangles. 
            Spread the area constraints.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.FormSkeleton(TriangleNet.Geometry.IPolygon)">
            <summary>
            Create the segments of a triangulation, including PSLG segments and edges 
            on the convex hull.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.InfectHull">
            <summary>
            Virally infect all of the triangles of the convex hull that are not 
            protected by subsegments. Where there are subsegments, set boundary 
            markers as appropriate.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.Plague">
             <summary>
             Spread the virus from all infected triangles to any neighbors not 
             protected by subsegments. Delete all infected triangles.
             </summary>
             <remarks>
             This is the procedure that actually creates holes and concavities.
            
             This procedure operates in two phases. The first phase identifies all
             the triangles that will die, and marks them as infected. They are
             marked to ensure that each triangle is added to the virus pool only
             once, so the procedure will terminate.
            
             The second phase actually eliminates the infected triangles. It also
             eliminates orphaned vertices.
             </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.FindDirection(TriangleNet.Topology.Otri@,TriangleNet.Geometry.Vertex)">
            <summary>
            Find the first triangle on the path from one point to another.
            </summary>
            <param name="searchtri"></param>
            <param name="searchpoint"></param>
            <returns>
            The return value notes whether the destination or apex of the found
            triangle is collinear with the two points in question.</returns>
            <remarks>
            Finds the triangle that intersects a line segment drawn from the
            origin of 'searchtri' to the point 'searchpoint', and returns the result
            in 'searchtri'. The origin of 'searchtri' does not change, even though
            the triangle returned may differ from the one passed in. This routine
            is used to find the direction to move in to get from one point to
            another.
            </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.SegmentIntersection(TriangleNet.Topology.Otri@,TriangleNet.Topology.Osub@,TriangleNet.Geometry.Vertex)">
             <summary>
             Find the intersection of an existing segment and a segment that is being 
             inserted. Insert a vertex at the intersection, splitting an existing subsegment.
             </summary>
             <param name="splittri"></param>
             <param name="splitsubseg"></param>
             <param name="endpoint2"></param>
             <remarks>
             The segment being inserted connects the apex of splittri to endpoint2.
             splitsubseg is the subsegment being split, and MUST adjoin splittri.
             Hence, endpoints of the subsegment being split are the origin and
             destination of splittri.
            
             On completion, splittri is a handle having the newly inserted
             intersection point as its origin, and endpoint1 as its destination.
             </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.ScoutSegment(TriangleNet.Topology.Otri@,TriangleNet.Geometry.Vertex,System.Int32)">
             <summary>
             Scout the first triangle on the path from one endpoint to another, and check 
             for completion (reaching the second endpoint), a collinear vertex, or the 
             intersection of two segments.
             </summary>
             <param name="searchtri"></param>
             <param name="endpoint2"></param>
             <param name="newmark"></param>
             <returns>Returns true if the entire segment is successfully inserted, and false 
             if the job must be finished by ConstrainedEdge().</returns>
             <remarks>
             If the first triangle on the path has the second endpoint as its
             destination or apex, a subsegment is inserted and the job is done.
            
             If the first triangle on the path has a destination or apex that lies on
             the segment, a subsegment is inserted connecting the first endpoint to
             the collinear vertex, and the search is continued from the collinear
             vertex.
            
             If the first triangle on the path has a subsegment opposite its origin,
             then there is a segment that intersects the segment being inserted.
             Their intersection vertex is inserted, splitting the subsegment.
             </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.DelaunayFixup(TriangleNet.Topology.Otri@,System.Boolean)">
             <summary>
             Enforce the Delaunay condition at an edge, fanning out recursively from 
             an existing vertex. Pay special attention to stacking inverted triangles.
             </summary>
             <param name="fixuptri"></param>
             <param name="leftside">Indicates whether or not fixuptri is to the left of 
             the segment being inserted. (Imagine that the segment is pointing up from
             endpoint1 to endpoint2.)</param>
             <remarks>
             This is a support routine for inserting segments into a constrained
             Delaunay triangulation.
            
             The origin of fixuptri is treated as if it has just been inserted, and
             the local Delaunay condition needs to be enforced. It is only enforced
             in one sector, however, that being the angular range defined by
             fixuptri.
            
             This routine also needs to make decisions regarding the "stacking" of
             triangles. (Read the description of ConstrainedEdge() below before
             reading on here, so you understand the algorithm.) If the position of
             the new vertex (the origin of fixuptri) indicates that the vertex before
             it on the polygon is a reflex vertex, then "stack" the triangle by
             doing nothing.  (fixuptri is an inverted triangle, which is how stacked
             triangles are identified.)
            
             Otherwise, check whether the vertex before that was a reflex vertex.
             If so, perform an edge flip, thereby eliminating an inverted triangle
             (popping it off the stack). The edge flip may result in the creation
             of a new inverted triangle, depending on whether or not the new vertex
             is visible to the vertex three edges behind on the polygon.
            
             If neither of the two vertices behind the new vertex are reflex
             vertices, fixuptri and fartri, the triangle opposite it, are not
             inverted; hence, ensure that the edge between them is locally Delaunay.
             </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.ConstrainedEdge(TriangleNet.Topology.Otri@,TriangleNet.Geometry.Vertex,System.Int32)">
             <summary>
             Force a segment into a constrained Delaunay triangulation by deleting the 
             triangles it intersects, and triangulating the polygons that form on each 
             side of it.
             </summary>
             <param name="starttri"></param>
             <param name="endpoint2"></param>
             <param name="newmark"></param>
             <remarks>
             Generates a single subsegment connecting 'endpoint1' to 'endpoint2'.
             The triangle 'starttri' has 'endpoint1' as its origin.  'newmark' is the
             boundary marker of the segment.
            
             To insert a segment, every triangle whose interior intersects the
             segment is deleted. The union of these deleted triangles is a polygon
             (which is not necessarily monotone, but is close enough), which is
             divided into two polygons by the new segment. This routine's task is
             to generate the Delaunay triangulation of these two polygons.
            
             You might think of this routine's behavior as a two-step process.  The
             first step is to walk from endpoint1 to endpoint2, flipping each edge
             encountered.  This step creates a fan of edges connected to endpoint1,
             including the desired edge to endpoint2. The second step enforces the
             Delaunay condition on each side of the segment in an incremental manner:
             proceeding along the polygon from endpoint1 to endpoint2 (this is done
             independently on each side of the segment), each vertex is "enforced"
             as if it had just been inserted, but affecting only the previous
             vertices. The result is the same as if the vertices had been inserted
             in the order they appear on the polygon, so the result is Delaunay.
            
             In truth, ConstrainedEdge() interleaves these two steps. The procedure
             walks from endpoint1 to endpoint2, and each time an edge is encountered
             and flipped, the newly exposed vertex (at the far end of the flipped
             edge) is "enforced" upon the previously flipped edges, usually affecting
             only one side of the polygon (depending upon which side of the segment
             the vertex falls on).
            
             The algorithm is complicated by the need to handle polygons that are not
             convex.  Although the polygon is not necessarily monotone, it can be
             triangulated in a manner similar to the stack-based algorithms for
             monotone polygons. For each reflex vertex (local concavity) of the
             polygon, there will be an inverted triangle formed by one of the edge
             flips. (An inverted triangle is one with negative area - that is, its
             vertices are arranged in clockwise order - and is best thought of as a
             wrinkle in the fabric of the mesh.)  Each inverted triangle can be
             thought of as a reflex vertex pushed on the stack, waiting to be fixed
             later.
            
             A reflex vertex is popped from the stack when a vertex is inserted that
             is visible to the reflex vertex. (However, if the vertex behind the
             reflex vertex is not visible to the reflex vertex, a new inverted
             triangle will take its place on the stack.) These details are handled
             by the DelaunayFixup() routine above.
             </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.InsertSegment(TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,System.Int32)">
            <summary>
            Insert a PSLG segment into a triangulation.
            </summary>
            <param name="endpoint1"></param>
            <param name="endpoint2"></param>
            <param name="newmark"></param>
        </member>
        <member name="M:TriangleNet.Meshing.ConstraintMesher.MarkHull">
            <summary>
            Cover the convex hull of a triangulation with subsegments.
            </summary>
        </member>
        <member name="T:TriangleNet.Meshing.ConstraintOptions">
            <summary>
            Mesh constraint options for polygon triangulation.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.ConstraintOptions.UseRegions">
            <summary>
            Gets or sets a value indicating whether to use regions.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.ConstraintOptions.ConformingDelaunay">
            <summary>
            Gets or sets a value indicating whether to create a Conforming
            Delaunay triangulation.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.ConstraintOptions.Convex">
            <summary>
            Gets or sets a value indicating whether to enclose the convex
            hull with segments.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.ConstraintOptions.SegmentSplitting">
            <summary>
            Gets or sets a flag indicating whether to suppress boundary
            segment splitting.
            </summary>
            <remarks>
            0 = split segments (default)
            1 = no new vertices on the boundary
            2 = prevent all segment splitting, including internal boundaries
            </remarks>
        </member>
        <member name="T:TriangleNet.Meshing.Converter">
            <summary>
            The Converter class provides methods for mesh reconstruction and conversion.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.Converter.Instance">
            <summary>
            Gets the <see cref="T:TriangleNet.Meshing.Converter"/> instance.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Converter.ToMesh(TriangleNet.Geometry.Polygon,System.Collections.Generic.ICollection{TriangleNet.Geometry.ITriangle})">
            <summary>
            Reconstruct a triangulation from its raw data representation.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Converter.ToMesh(TriangleNet.Geometry.Polygon,TriangleNet.Geometry.ITriangle[],TriangleNet.Configuration)">
            <summary>
            Reconstruct a triangulation from its raw data representation.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Converter.SetNeighbors(TriangleNet.Mesh,TriangleNet.Geometry.ITriangle[])">
            <summary>
            Finds the adjacencies between triangles by forming a stack of triangles for
            each vertex. Each triangle is on three different stacks simultaneously.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Converter.SetSegments(TriangleNet.Mesh,TriangleNet.Geometry.Polygon,System.Collections.Generic.List{TriangleNet.Topology.Otri}[])">
            <summary>
            Finds the adjacencies between triangles and subsegments.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Converter.ToDCEL(TriangleNet.Mesh)">
            <summary>
            Convert the triangle mesh topology to DCEL.
            </summary>
            <param name="mesh"></param>
            <returns></returns>
        </member>
        <member name="T:TriangleNet.Meshing.Data.BadSubseg">
            <summary>
            A queue used to store encroached subsegments.
            </summary>
            <remarks>
            Each subsegment's vertices are stored so that we can check whether a 
            subsegment is still the same.
            </remarks>
        </member>
        <member name="T:TriangleNet.Meshing.Data.BadTriangle">
            <summary>
            A queue used to store bad triangles.
            </summary>
            <remarks>
            The key is the square of the cosine of the smallest angle of the triangle.
            Each triangle's vertices are stored so that one can check whether a
            triangle is still the same.
            </remarks>
        </member>
        <member name="T:TriangleNet.Meshing.Data.BadTriQueue">
            <summary>
            A (priority) queue for bad triangles.
            </summary>
            <remarks>
            The queue is actually a set of 4096 queues. I use multiple queues to
            give priority to smaller angles. I originally implemented a heap, but
            the queues are faster by a larger margin than I'd suspected.
            </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.Data.BadTriQueue.Enqueue(TriangleNet.Meshing.Data.BadTriangle)">
            <summary>
            Add a bad triangle data structure to the end of a queue.
            </summary>
            <param name="badtri">The bad triangle to enqueue.</param>
        </member>
        <member name="M:TriangleNet.Meshing.Data.BadTriQueue.Enqueue(TriangleNet.Topology.Otri@,System.Double,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex)">
            <summary>
            Add a bad triangle to the end of a queue.
            </summary>
            <param name="enqtri"></param>
            <param name="minedge"></param>
            <param name="apex"></param>
            <param name="org"></param>
            <param name="dest"></param>
        </member>
        <member name="M:TriangleNet.Meshing.Data.BadTriQueue.Dequeue">
            <summary>
            Remove a triangle from the front of the queue.
            </summary>
            <returns></returns>
        </member>
        <member name="T:TriangleNet.Meshing.GenericMesher">
            <summary>
            Create meshes of point sets or polygons.
            </summary>
            <remarks>
            If not specified otherwise, the default triangulation algorithm used is <see cref="T:TriangleNet.Meshing.Algorithm.Dwyer" />.
            </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Meshing.GenericMesher" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.#ctor(TriangleNet.Meshing.ITriangulator)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Meshing.GenericMesher" /> class.
            </summary>
            <param name="triangulator">The <see cref="T:TriangleNet.Meshing.ITriangulator" /> algorithm implementation.</param>
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.#ctor(TriangleNet.Configuration)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Meshing.GenericMesher" /> class.
            </summary>
            <param name="config">The <see cref="T:TriangleNet.Configuration" />.</param>
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.#ctor(TriangleNet.Meshing.ITriangulator,TriangleNet.Configuration)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Meshing.GenericMesher" /> class.
            </summary>
            <param name="triangulator">The <see cref="T:TriangleNet.Meshing.ITriangulator" /> algorithm implementation.</param>
            <param name="config">The <see cref="T:TriangleNet.Configuration" />.</param>
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.Triangulate(System.Collections.Generic.IList{TriangleNet.Geometry.Vertex})">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.Triangulate(TriangleNet.Geometry.IPolygon)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.ConstraintOptions)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.QualityOptions)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.ConstraintOptions,TriangleNet.Meshing.QualityOptions)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.StructuredMesh(System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Generates a structured mesh with bounds [0, 0, width, height].
            </summary>
            <param name="width">Width of the mesh (must be > 0).</param>
            <param name="height">Height of the mesh (must be > 0).</param>
            <param name="nx">Number of segments in x direction.</param>
            <param name="ny">Number of segments in y direction.</param>
            <returns>Mesh</returns>
        </member>
        <member name="M:TriangleNet.Meshing.GenericMesher.StructuredMesh(TriangleNet.Geometry.Rectangle,System.Int32,System.Int32)">
            <summary>
            Generates a structured mesh.
            </summary>
            <param name="bounds">Bounds of the mesh.</param>
            <param name="nx">Number of segments in x direction.</param>
            <param name="ny">Number of segments in y direction.</param>
            <returns>Mesh</returns>
        </member>
        <member name="T:TriangleNet.Meshing.IConstraintMesher">
            <summary>
            Interface for polygon triangulation.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.IConstraintMesher.Triangulate(TriangleNet.Geometry.IPolygon)">
            <summary>
            Triangulates a polygon.
            </summary>
            <param name="polygon">The polygon.</param>
            <returns>Mesh</returns>
        </member>
        <member name="M:TriangleNet.Meshing.IConstraintMesher.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.ConstraintOptions)">
            <summary>
            Triangulates a polygon, applying constraint options.
            </summary>
            <param name="polygon">The polygon.</param>
            <param name="options">Constraint options.</param>
            <returns>Mesh</returns>
        </member>
        <member name="T:TriangleNet.Meshing.IMesh">
            <summary>
            Mesh interface.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.IMesh.Vertices">
            <summary>
            Gets the vertices of the mesh.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.IMesh.Edges">
            <summary>
            Gets the edges of the mesh.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.IMesh.Segments">
            <summary>
            Gets the segments (constraint edges) of the mesh.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.IMesh.Triangles">
            <summary>
            Gets the triangles of the mesh.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.IMesh.Holes">
            <summary>
            Gets the holes of the mesh.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.IMesh.Bounds">
            <summary>
            Gets the bounds of the mesh.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.IMesh.Renumber">
            <summary>
            Renumber mesh vertices and triangles.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.IMesh.Refine(TriangleNet.Meshing.QualityOptions,System.Boolean)">
            <summary>
            Refine the mesh.
            </summary>
            <param name="quality">The quality constraints.</param>
            <param name="delaunay">
            A value indicating, whether the refined mesh should be Conforming Delaunay.
            </param>
        </member>
        <member name="T:TriangleNet.Meshing.IQualityMesher">
            <summary>
            Interface for polygon triangulation with quality constraints.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.IQualityMesher.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.QualityOptions)">
            <summary>
            Triangulates a polygon, applying quality options.
            </summary>
            <param name="polygon">The polygon.</param>
            <param name="quality">Quality options.</param>
            <returns>Mesh</returns>
        </member>
        <member name="M:TriangleNet.Meshing.IQualityMesher.Triangulate(TriangleNet.Geometry.IPolygon,TriangleNet.Meshing.ConstraintOptions,TriangleNet.Meshing.QualityOptions)">
            <summary>
            Triangulates a polygon, applying quality and constraint options.
            </summary>
            <param name="polygon">The polygon.</param>
            <param name="options">Constraint options.</param>
            <param name="quality">Quality options.</param>
            <returns>Mesh</returns>
        </member>
        <member name="T:TriangleNet.Meshing.Iterators.EdgeIterator">
            <summary>
            Enumerates the edges of a triangulation.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Iterators.EdgeIterator.EnumerateEdges(TriangleNet.Meshing.IMesh)">
            <summary>
            Enumerate all edges of the given mesh.
            </summary>
            <param name="mesh"></param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Meshing.Iterators.EdgeIterator.EnumerateEdges(TriangleNet.Meshing.IMesh,System.Boolean)">
            <summary>
            Enumerate all edges of the given mesh.
            </summary>
            <param name="mesh"></param>
            <param name="skipSegments"></param>
            <returns></returns>
            <remarks>
            In contrast to <see cref="M:TriangleNet.Meshing.Iterators.EdgeIterator.EnumerateEdges(TriangleNet.Meshing.IMesh)"/> this method will return
            objects that include the vertex information (and not only the indices).
            </remarks>
        </member>
        <member name="T:TriangleNet.Meshing.Iterators.RegionIterator">
            <summary>
            Iterates the region a given triangle belongs to and applies an action
            to each connected trianlge in that region. 
            </summary>
            <remarks>
            The default action is to set the region id and area constraint.
            </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.Iterators.RegionIterator.#ctor(TriangleNet.Mesh)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Meshing.Iterators.RegionIterator" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Iterators.RegionIterator.Process(TriangleNet.Topology.Triangle,System.Int32)">
            <summary>
            Set the region attribute of all trianlges connected to given triangle.
            </summary>
            <param name="triangle">The triangle seed.</param>
            <param name="boundary">If non-zero, process all triangles of the
            region that is enclosed by segments with given boundary label.</param>
        </member>
        <member name="M:TriangleNet.Meshing.Iterators.RegionIterator.Process(TriangleNet.Topology.Triangle,System.Action{TriangleNet.Topology.Triangle},System.Int32)">
            <summary>
            Process all trianlges connected to given triangle and apply given action.
            </summary>
            <param name="triangle">The seeding triangle.</param>
            <param name="action">The action to apply to each triangle.</param>
            <param name="boundary">If non-zero, process all triangles of the
            region that is enclosed by segments with given boundary label.</param>
        </member>
        <member name="M:TriangleNet.Meshing.Iterators.RegionIterator.ProcessRegion(System.Action{TriangleNet.Topology.Triangle},System.Func{TriangleNet.Topology.SubSegment,System.Boolean})">
            <summary>
            Apply given action to each triangle of selected region.
            </summary>
            <param name="action"></param>
            <param name="protector"></param>
        </member>
        <member name="T:TriangleNet.Meshing.Iterators.VertexCirculator">
            <summary>
            Vertex circulator to enumerate the vertices connected to a mesh vertex.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Iterators.VertexCirculator.#ctor(TriangleNet.Mesh)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Meshing.Iterators.VertexCirculator" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.Iterators.VertexCirculator.EnumerateVertices(TriangleNet.Geometry.Vertex)">
            <summary>
            Enumerate all vertices adjacent to given vertex.
            </summary>
            <param name="vertex">The center vertex.</param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Meshing.Iterators.VertexCirculator.EnumerateTriangles(TriangleNet.Geometry.Vertex)">
            <summary>
            Enumerate all triangles adjacent to given vertex.
            </summary>
            <param name="vertex">The center vertex.</param>
            <returns></returns>
        </member>
        <member name="T:TriangleNet.Meshing.ITriangulator">
            <summary>
            Interface for point set triangulation.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.ITriangulator.Triangulate(System.Collections.Generic.IList{TriangleNet.Geometry.Vertex},TriangleNet.Configuration)">
            <summary>
            Triangulates a point set.
            </summary>
            <param name="points">Collection of points.</param>
            <param name="config"></param>
            <returns>Mesh</returns>
        </member>
        <member name="T:TriangleNet.Meshing.QualityMesher">
            <summary>
            Provides methods for mesh quality enforcement and testing.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.QualityMesher.Apply(TriangleNet.Meshing.QualityOptions,System.Boolean)">
            <summary>
            Apply quality constraints to a mesh.
            </summary>
            <param name="quality">The quality constraints.</param>
            <param name="delaunay">A value indicating, whether the refined mesh should be Conforming Delaunay.</param>
        </member>
        <member name="M:TriangleNet.Meshing.QualityMesher.AddBadSubseg(TriangleNet.Meshing.Data.BadSubseg)">
            <summary>
            Add a bad subsegment to the queue.
            </summary>
            <param name="badseg">Bad subsegment.</param>
        </member>
        <member name="M:TriangleNet.Meshing.QualityMesher.CheckSeg4Encroach(TriangleNet.Topology.Osub@)">
             <summary>
             Check a subsegment to see if it is encroached; add it to the list if it is.
             </summary>
             <param name="testsubseg">The subsegment to check.</param>
             <returns>Returns a nonzero value if the subsegment is encroached.</returns>
             <remarks>
             A subsegment is encroached if there is a vertex in its diametral lens.
             For Ruppert's algorithm (-D switch), the "diametral lens" is the
             diametral circle. For Chew's algorithm (default), the diametral lens is
             just big enough to enclose two isosceles triangles whose bases are the
             subsegment. Each of the two isosceles triangles has two angles equal
             to 'b.minangle'.
            
             Chew's algorithm does not require diametral lenses at all--but they save
             time. Any vertex inside a subsegment's diametral lens implies that the
             triangle adjoining the subsegment will be too skinny, so it's only a
             matter of time before the encroaching vertex is deleted by Chew's
             algorithm. It's faster to simply not insert the doomed vertex in the
             first place, which is why I use diametral lenses with Chew's algorithm.
             </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.QualityMesher.TestTriangle(TriangleNet.Topology.Otri@)">
            <summary>
            Test a triangle for quality and size.
            </summary>
            <param name="testtri">Triangle to check.</param>
            <remarks>
            Tests a triangle to see if it satisfies the minimum angle condition and
            the maximum area condition.  Triangles that aren't up to spec are added
            to the bad triangle queue.
            </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.QualityMesher.TallyEncs">
            <summary>
            Traverse the entire list of subsegments, and check each to see if it 
            is encroached. If so, add it to the list.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.QualityMesher.SplitEncSegs(System.Boolean)">
            <summary>
            Split all the encroached subsegments.
            </summary>
            <param name="triflaws">A flag that specifies whether one should take 
            note of new bad triangles that result from inserting vertices to repair 
            encroached subsegments.</param>
            <remarks>
            Each encroached subsegment is repaired by splitting it - inserting a
            vertex at or near its midpoint.  Newly inserted vertices may encroach
            upon other subsegments; these are also repaired.
            </remarks>
        </member>
        <member name="M:TriangleNet.Meshing.QualityMesher.TallyFaces">
            <summary>
            Test every triangle in the mesh for quality measures.
            </summary>
        </member>
        <member name="M:TriangleNet.Meshing.QualityMesher.SplitTriangle(TriangleNet.Meshing.Data.BadTriangle)">
            <summary>
            Inserts a vertex at the circumcenter of a triangle. Deletes 
            the newly inserted vertex if it encroaches upon a segment.
            </summary>
            <param name="badtri"></param>
        </member>
        <member name="M:TriangleNet.Meshing.QualityMesher.EnforceQuality">
            <summary>
            Remove all the encroached subsegments and bad triangles from the triangulation.
            </summary>
        </member>
        <member name="T:TriangleNet.Meshing.QualityOptions">
            <summary>
            Mesh constraint options for quality triangulation.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.QualityOptions.MaximumAngle">
            <summary>
            Gets or sets a maximum angle constraint.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.QualityOptions.MinimumAngle">
            <summary>
            Gets or sets a minimum angle constraint.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.QualityOptions.MaximumArea">
            <summary>
            Gets or sets a maximum triangle area constraint.
            </summary>
        </member>
        <member name="P:TriangleNet.Meshing.QualityOptions.UserTest">
            <summary>
            Gets or sets a user-defined triangle constraint.
            </summary>
            <remarks>
            The test function will be called for each triangle in the mesh. The
            second argument is the area of the triangle tested. If the function
            returns true, the triangle is considered bad and will be refined.
            </remarks>
        </member>
        <member name="P:TriangleNet.Meshing.QualityOptions.Exclude">
            <summary>
            Gets or sets a test function for excluding triangles from refinement.
            </summary>
            <remarks>
            The exclude test takes higher priority than all other test, i.e. if a
            triangle passes the exclude test, no other test will be executed.
            </remarks>
        </member>
        <member name="P:TriangleNet.Meshing.QualityOptions.VariableArea">
            <summary>
            Gets or sets an area constraint per triangle.
            </summary>
            <remarks>
            If this flag is set to true, the <see cref="P:TriangleNet.Geometry.ITriangle.Area"/> value will
            be used to check if a triangle needs refinement.
            </remarks>
        </member>
        <member name="P:TriangleNet.Meshing.QualityOptions.SteinerPoints">
            <summary>
            Gets or sets the maximum number of Steiner points to be inserted into the mesh.
            </summary>
            <remarks>
            If the value is 0 (default), an unknown number of Steiner points may be inserted
            to meet the other quality constraints.
            </remarks>
        </member>
        <member name="P:TriangleNet.Meshing.QualityOptions.UseLegacyRefinement">
            <summary>
            Gets or sets a value indicating whether to use the legacy refinement strategy (default = <c>false</c>).
            </summary>
            <remarks>
            If this flag is set to true, the original Triangle refinement algorithm will be
            used (Ruppert's algorithm). Otherwise the aCute algorithm used.
            </remarks>
        </member>
        <member name="T:TriangleNet.MeshValidator">
            <summary>
            Mesh validation helper.
            </summary>
        </member>
        <member name="M:TriangleNet.MeshValidator.IsConsistent(TriangleNet.Mesh)">
            <summary>
            Test the mesh for topological consistency.
            </summary>
            <param name="mesh">The mesh.</param>
            <returns>True, if mesh is topologically consistent.</returns>
        </member>
        <member name="M:TriangleNet.MeshValidator.IsDelaunay(TriangleNet.Mesh)">
            <summary>
            Check whether the mesh is (conforming) Delaunay.
            </summary>
            <param name="mesh">The mesh.</param>
            <returns>True, if mesh is (conforming) Delaunay.</returns>
        </member>
        <member name="M:TriangleNet.MeshValidator.IsConstrainedDelaunay(TriangleNet.Mesh)">
            <summary>
            Check whether the mesh is (constrained) Delaunay.
            </summary>
            <param name="mesh">The mesh.</param>
            <returns>True, if mesh is (constrained) Delaunay.</returns>
        </member>
        <member name="M:TriangleNet.MeshValidator.IsDelaunay(TriangleNet.Mesh,System.Boolean)">
            <summary>
            Ensure that the mesh is (constrained) Delaunay.
            </summary>
        </member>
        <member name="M:TriangleNet.MeshValidator.GetDegenerateBoundaryTriangles(TriangleNet.Meshing.IMesh,System.Double)">
            <summary>
            Check whether the mesh has degenerate boundary triangles.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="threshold">Threshold for what angle is considered invalid (too small).</param>
            <returns></returns>
        </member>
        <member name="T:TriangleNet.NewLocation">
            <summary>
            Find new Steiner point locations.
            </summary>
            <remarks>
            See https://www.cise.ufl.edu/~ungor/aCute/index.html
            </remarks>
        </member>
        <member name="M:TriangleNet.NewLocation.FindLocation(TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,System.Double@,System.Double@,System.Boolean,TriangleNet.Topology.Otri)">
            <summary>
            Find a new location for a Steiner point.
            </summary>
            <param name="org"></param>
            <param name="dest"></param>
            <param name="apex"></param>
            <param name="xi"></param>
            <param name="eta"></param>
            <param name="offcenter"></param>
            <param name="badotri"></param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.NewLocation.FindNewLocationWithoutMaxAngle(TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,System.Double@,System.Double@,System.Boolean,TriangleNet.Topology.Otri)">
            <summary>
            Find a new location for a Steiner point.
            </summary>
            <param name="torg"></param>
            <param name="tdest"></param>
            <param name="tapex"></param>
            <param name="xi"></param>
            <param name="eta"></param>
            <param name="offcenter"></param>
            <param name="badotri"></param>
        </member>
        <member name="M:TriangleNet.NewLocation.FindNewLocation(TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,System.Double@,System.Double@,System.Boolean,TriangleNet.Topology.Otri)">
            <summary>
            Find a new location for a Steiner point.
            </summary>
            <param name="torg"></param>
            <param name="tdest"></param>
            <param name="tapex"></param>
            <param name="xi"></param>
            <param name="eta"></param>
            <param name="offcenter"></param>
            <param name="badotri"></param>
        </member>
        <member name="M:TriangleNet.NewLocation.LongestShortestEdge(System.Double,System.Double,System.Double)">
            <summary>
            Given square of edge lengths of a triangle,
            determine its orientation
            </summary>
            <param name="aodist"></param>
            <param name="dadist"></param>
            <param name="dodist"></param>
            <returns>Returns a number indicating an orientation.</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.DoSmoothing(TriangleNet.Topology.Otri,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,System.Double[]@)">
            <summary>
            Checks if smothing is possible for a given bad triangle.
            </summary>
            <param name="badotri"></param>
            <param name="torg"></param>
            <param name="tdest"></param>
            <param name="tapex"></param>
            <param name="newloc">The new location for the point, if somothing is possible.</param>
            <returns>Returns 1, 2 or 3 if smoothing will work, 0 otherwise.</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.GetStarPoints(TriangleNet.Topology.Otri,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex,System.Int32,System.Double[]@)">
            <summary>
            Finds the star of a given point.
            </summary>
            <param name="badotri"></param>
            <param name="p"></param>
            <param name="q"></param>
            <param name="r"></param>
            <param name="whichPoint"></param>
            <param name="points">List of points on the star of the given point.</param>
            <returns>Number of points on the star of the given point.</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.GetNeighborsVertex(TriangleNet.Topology.Otri,System.Double,System.Double,System.Double,System.Double,System.Double[]@,TriangleNet.Topology.Otri@)">
            <summary>
            Gets a neighbours vertex.
            </summary>
            <param name="badotri"></param>
            <param name="first_x"></param>
            <param name="first_y"></param>
            <param name="second_x"></param>
            <param name="second_y"></param>
            <param name="thirdpoint">Neighbor's third vertex incident to given edge.</param>
            <param name="neighotri">Pointer for the neighbor triangle.</param>
            <returns>Returns true if vertex was found.</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.GetWedgeIntersectionWithoutMaxAngle(System.Int32,System.Double[],System.Double[]@)">
            <summary>
            Find a new point location by wedge intersection.
            </summary>
            <param name="numpoints"></param>
            <param name="points"></param>
            <param name="newloc">A new location for the point according to surrounding points.</param>
            <returns>Returns true if new location found</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.GetWedgeIntersection(System.Int32,System.Double[],System.Double[]@)">
            <summary>
            Find a new point location by wedge intersection.
            </summary>
            <param name="numpoints"></param>
            <param name="points"></param>
            <param name="newloc">A new location for the point according to surrounding points.</param>
            <returns>Returns true if new location found</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.ValidPolygonAngles(System.Int32,System.Double[])">
            <summary>
            Check polygon for min angle.
            </summary>
            <param name="numpoints"></param>
            <param name="points"></param>
            <returns>Returns true if the polygon has angles greater than 2*minangle.</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.IsBadPolygonAngle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Given three coordinates of a polygon, tests to see if it satisfies the minimum
            angle condition for relocation.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <returns>Returns true, if it is a BAD polygon corner, returns false if it is a GOOD
            polygon corner</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.LineLineIntersection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double[]@)">
            <summary>
            Given four points representing two lines, returns the intersection point.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="x4"></param>
            <param name="y4"></param>
            <param name="p">The intersection point.</param>
            <remarks>
            referenced to: http://local.wasp.uwa.edu.au/~pbourke/geometry/
            </remarks>
        </member>
        <member name="M:TriangleNet.NewLocation.HalfPlaneIntersection(System.Int32,System.Double[]@,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the convex polygon which is the intersection of the given convex
            polygon with the halfplane on the left side (regarding the directional vector)
            of the given line.
            </summary>
            <param name="numvertices"></param>
            <param name="convexPoly"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <returns></returns>
            <remarks>
            http://www.mathematik.uni-ulm.de/stochastik/lehre/ws03_04/rt/Geometry2D.ps
            </remarks>
        </member>
        <member name="M:TriangleNet.NewLocation.SplitConvexPolygon(System.Int32,System.Double[],System.Double,System.Double,System.Double,System.Double,System.Double[][])">
            <summary>
            Splits a convex polygons into one or two polygons through the intersection
            with the given line (regarding the directional vector of the given line).
            </summary>
            <param name="numvertices"></param>
            <param name="convexPoly"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="polys"></param>
            <returns></returns>
            <remarks>
            http://www.mathematik.uni-ulm.de/stochastik/lehre/ws03_04/rt/Geometry2D.ps
            </remarks>
        </member>
        <member name="M:TriangleNet.NewLocation.LinePointLocation(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Determines on which side (relative to the direction) of the given line and the
            point lies (regarding the directional vector) of the given line.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
            <remarks>
            http://www.mathematik.uni-ulm.de/stochastik/lehre/ws03_04/rt/Geometry2D.ps
            </remarks>
        </member>
        <member name="M:TriangleNet.NewLocation.LineLineSegmentIntersection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double[]@)">
            <summary>
            Given four points representing one line and a line segment, returns the intersection point
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="x4"></param>
            <param name="y4"></param>
            <param name="p"></param>
            <remarks>
            referenced to: http://local.wasp.uwa.edu.au/~pbourke/geometry/
            </remarks>
        </member>
        <member name="M:TriangleNet.NewLocation.FindPolyCentroid(System.Int32,System.Double[],System.Double[]@)">
            <summary>
            Returns the centroid of a given polygon
            </summary>
            <param name="numpoints"></param>
            <param name="points"></param>
            <param name="centroid">Centroid of a given polygon </param>
        </member>
        <member name="M:TriangleNet.NewLocation.CircleLineIntersection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double[]@)">
            <summary>
            Given two points representing a line and  a radius together with a center point
            representing a circle, returns the intersection points.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="r"></param>
            <param name="p">Pointer to list of intersection points</param>
            <remarks>
            referenced to: http://local.wasp.uwa.edu.au/~pbourke/geometry/sphereline/
            </remarks>
        </member>
        <member name="M:TriangleNet.NewLocation.ChooseCorrectPoint(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Given three points, check if the point is the correct point that we are looking for.
            </summary>
            <param name="x1">P1 coordinates (bisector point of dual edge on triangle)</param>
            <param name="y1">P1 coordinates (bisector point of dual edge on triangle)</param>
            <param name="x2">P2 coordinates (intersection point)</param>
            <param name="y2">P2 coordinates (intersection point)</param>
            <param name="x3">P3 coordinates (circumcenter point)</param>
            <param name="y3">P3 coordinates (circumcenter point)</param>
            <param name="isObtuse"></param>
            <returns>Returns true, if given point is the correct one otherwise return false.</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.PointBetweenPoints(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double[]@)">
            <summary>
            This function returns a pointer array which first index indicates the whether
            the point is in between the other points, followed by coordinate pairs.
            </summary>
            <param name="x1">P1 coordinates [point of line] (point on Voronoi edge - intersection)</param>
            <param name="y1">P1 coordinates [point of line] (point on Voronoi edge - intersection)</param>
            <param name="x2">P2 coordinates [point of line] (circumcenter)</param>
            <param name="y2">P2 coordinates [point of line] (circumcenter)</param>
            <param name="x">P3 coordinates [point to be compared]	(neighbor's circumcenter)</param>
            <param name="y">P3 coordinates [point to be compared]	(neighbor's circumcenter)</param>
            <param name="p"></param>
        </member>
        <member name="M:TriangleNet.NewLocation.IsBadTriangleAngle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Given three coordinates of a triangle, tests a triangle to see if it satisfies
            the minimum and/or maximum angle condition.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <returns>Returns true, if it is a BAD triangle, returns false if it is a GOOD triangle.</returns>
        </member>
        <member name="M:TriangleNet.NewLocation.MinDistanceToNeighbor(System.Double,System.Double,TriangleNet.Topology.Otri@)">
            <summary>
            Given the triangulation, and a vertex returns the minimum distance to the
            vertices of the triangle where the given vertex located.
            </summary>
            <param name="newlocX"></param>
            <param name="newlocY"></param>
            <param name="searchtri"></param>
            <returns></returns>
        </member>
        <member name="T:TriangleNet.RobustPredicates">
            <summary>
            Adaptive exact arithmetic geometric predicates.
            </summary>
            <remarks>
            The adaptive exact arithmetic geometric predicates implemented herein are described in
            detail in the paper "Adaptive Precision Floating-Point Arithmetic and Fast Robust
            Geometric Predicates." by Jonathan Richard Shewchuk, see
            http://www.cs.cmu.edu/~quake/robust.html
            
            The macros of the original C code were automatically expanded using the Visual Studio
            command prompt with the command "CL /P /C EXACT.C", see
            http://msdn.microsoft.com/en-us/library/8z9z0bx6.aspx
            </remarks>
        </member>
        <member name="P:TriangleNet.RobustPredicates.Default">
            <summary>
            Gets the default configuration instance.
            </summary>
        </member>
        <member name="M:TriangleNet.RobustPredicates.#cctor">
             <summary>
             Initialize the variables used for exact arithmetic.  
             </summary>
             <remarks>
             'epsilon' is the largest power of two such that 1.0 + epsilon = 1.0 in
             floating-point arithmetic. 'epsilon' bounds the relative roundoff
             error. It is used for floating-point error analysis.
            
             'splitter' is used to split floating-point numbers into two half-
             length significands for exact multiplication.
            
             I imagine that a highly optimizing compiler might be too smart for its
             own good, and somehow cause this routine to fail, if it pretends that
             floating-point arithmetic is too much like double arithmetic.
            
             Don't change this routine unless you fully understand it.
             </remarks>
        </member>
        <member name="M:TriangleNet.RobustPredicates.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.RobustPredicates" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.RobustPredicates.CounterClockwise(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point)">
            <inheritdoc/>
        </member>
        <member name="M:TriangleNet.RobustPredicates.InCircle(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point)">
            <inheritdoc/>
        </member>
        <member name="M:TriangleNet.RobustPredicates.NonRegular(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point)">
            <summary>
            Return a positive value if the point pd is incompatible with the circle 
            or plane passing through pa, pb, and pc (meaning that pd is inside the 
            circle or below the plane); a negative value if it is compatible; and 
            zero if the four points are cocircular/coplanar. The points pa, pb, and 
            pc must be in counterclockwise order, or the sign of the result will be 
            reversed.
            </summary>
            <param name="pa">Point a.</param>
            <param name="pb">Point b.</param>
            <param name="pc">Point c.</param>
            <param name="pd">Point d.</param>
            <returns>Return a positive value if the point pd lies inside the circle passing through 
            pa, pb, and pc; a negative value if it lies outside; and zero if the four points 
            are cocircular.</returns>
        </member>
        <member name="M:TriangleNet.RobustPredicates.FindCircumcenter(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,System.Double@,System.Double@,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:TriangleNet.RobustPredicates.FindCircumcenter(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:TriangleNet.RobustPredicates.FastExpansionSumZeroElim(System.Int32,System.Double[],System.Int32,System.Double[],System.Double[])">
            <summary>
            Sum two expansions, eliminating zero components from the output expansion.  
            </summary>
            <param name="elen"></param>
            <param name="e"></param>
            <param name="flen"></param>
            <param name="f"></param>
            <param name="h"></param>
            <returns></returns>
            <remarks>
            Sets h = e + f.  See the Robust Predicates paper for details.
            
            If round-to-even is used (as with IEEE 754), maintains the strongly nonoverlapping
            property.  (That is, if e is strongly nonoverlapping, h will be also.) Does NOT
            maintain the nonoverlapping or nonadjacent properties. 
            </remarks>
        </member>
        <member name="M:TriangleNet.RobustPredicates.ScaleExpansionZeroElim(System.Int32,System.Double[],System.Double,System.Double[])">
            <summary>
            Multiply an expansion by a scalar, eliminating zero components from the output expansion.  
            </summary>
            <param name="elen"></param>
            <param name="e"></param>
            <param name="b"></param>
            <param name="h"></param>
            <returns></returns>
            <remarks>
            Sets h = be.  See my Robust Predicates paper for details.
            
            Maintains the nonoverlapping property.  If round-to-even is used (as with IEEE 754),
            maintains the strongly nonoverlapping and nonadjacent properties as well. (That is,
            if e has one of these properties, so will h.)
            </remarks>
        </member>
        <member name="M:TriangleNet.RobustPredicates.Estimate(System.Int32,System.Double[])">
            <summary>
            Produce a one-word estimate of an expansion's value. 
            </summary>
            <param name="elen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.RobustPredicates.CounterClockwiseAdapt(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,System.Double)">
            <summary>
            Return a positive value if the points pa, pb, and pc occur in counterclockwise
            order; a negative value if they occur in clockwise order; and zero if they are
            collinear. The result is also a rough approximation of twice the signed area of
            the triangle defined by the three points. 
            </summary>
            <param name="pa"></param>
            <param name="pb"></param>
            <param name="pc"></param>
            <param name="detsum"></param>
            <returns></returns>
            <remarks>
            Uses exact arithmetic if necessary to ensure a correct answer. The result returned
            is the determinant of a matrix. This determinant is computed adaptively, in the
            sense that exact arithmetic is used only to the degree it is needed to ensure that
            the returned value has the correct sign.  Hence, this function is usually quite fast,
            but will run more slowly when the input points are collinear or nearly so.
            </remarks>
        </member>
        <member name="M:TriangleNet.RobustPredicates.InCircleAdapt(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,System.Double)">
            <summary>
            Return a positive value if the point pd lies inside the circle passing through
            pa, pb, and pc; a negative value if it lies outside; and zero if the four points
            are cocircular. The points pa, pb, and pc must be in counterclockwise order, or 
            the sign of the result will be reversed.
            </summary>
            <param name="pa"></param>
            <param name="pb"></param>
            <param name="pc"></param>
            <param name="pd"></param>
            <param name="permanent"></param>
            <returns></returns>
            <remarks>
            Uses exact arithmetic if necessary to ensure a correct answer. The result returned
            is the determinant of a matrix. This determinant is computed adaptively, in the
            sense that exact arithmetic is used only to the degree it is needed to ensure that
            the returned value has the correct sign. Hence, this function is usually quite fast,
            but will run more slowly when the input points are cocircular or nearly so.
            </remarks>
        </member>
        <member name="T:TriangleNet.Smoothing.SimpleSmoother">
            <summary>
            Simple mesh smoother implementation (Lloyd's relaxation algorithm).
            </summary>
            <remarks>
            Vertices which should not move (e.g. segment vertices) MUST have a
            boundary mark greater than 0.
            </remarks>
        </member>
        <member name="M:TriangleNet.Smoothing.SimpleSmoother.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Smoothing.SimpleSmoother" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Smoothing.SimpleSmoother.#ctor(TriangleNet.Voronoi.IVoronoiFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Smoothing.SimpleSmoother" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Smoothing.SimpleSmoother.#ctor(TriangleNet.Voronoi.IVoronoiFactory,TriangleNet.Configuration)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Smoothing.SimpleSmoother" /> class.
            </summary>
            <param name="factory">Voronoi object factory.</param>
            <param name="config">Configuration.</param>
        </member>
        <member name="M:TriangleNet.Smoothing.SimpleSmoother.Smooth(TriangleNet.Meshing.IMesh,System.Int32,System.Double)">
            <summary>
            Smooth mesh with a maximum given number of rounds of Voronoi
            iteration.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="limit">The maximum number of iterations. If
            non-positive, no iteration is applied at all.</param>
            <param name="tol">The desired tolerance on the result. At each
            iteration, the maximum movement by any side is considered, both for
            the previous and the current solutions. If their relative difference
            is not greater than the tolerance, the current solution is
            considered good enough already.</param>
            <returns>The number of actual iterations performed. It is 0 if a
            non-positive limit is passed. Otherwise, it is always a value
            between 1 and the limit (inclusive).
            </returns>
        </member>
        <member name="M:TriangleNet.Smoothing.SimpleSmoother.Centroid(TriangleNet.Topology.DCEL.Face,System.Double@,System.Double@)">
            <summary>
            Calculate the centroid of a polygon.
            </summary>
        </member>
        <member name="M:TriangleNet.Smoothing.SimpleSmoother.Rebuild(TriangleNet.Mesh)">
            <summary>
            Rebuild the input geometry.
            </summary>
        </member>
        <member name="T:TriangleNet.Smoothing.VoronoiFactory">
            <summary>
            Factory which re-uses objects in the smoothing loop to enhance performance.
            </summary>
            <remarks>
            See <see cref="T:TriangleNet.Smoothing.SimpleSmoother"/>.
            </remarks>
        </member>
        <member name="T:TriangleNet.Tools.AdjacencyMatrix">
            <summary>
            The adjacency matrix of the mesh.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.AdjacencyMatrix.ColumnCount">
            <summary>
            Gets the number of columns (nodes of the mesh).
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.AdjacencyMatrix.ColumnPointers">
            <summary>
            Gets the column pointers.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.AdjacencyMatrix.RowIndices">
            <summary>
            Gets the row indices.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.AdjacencyMatrix.#ctor(TriangleNet.Mesh)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Tools.AdjacencyMatrix" /> class.
            </summary>
            <param name="mesh">The mesh.</param>
            <remarks>
            NOTE: as a side effect, computing the adjacency matrix will affect the
            node numbering of the mesh.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.AdjacencyMatrix.#ctor(System.Int32[],System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Tools.AdjacencyMatrix" /> class.
            </summary>
            <param name="pcol">The column pointers.</param>
            <param name="irow">The row indices.</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:TriangleNet.Tools.AdjacencyMatrix.Bandwidth">
            <summary>
            Computes the bandwidth of an adjacency matrix.
            </summary>
            <returns>Bandwidth of the adjacency matrix.</returns>
        </member>
        <member name="M:TriangleNet.Tools.AdjacencyMatrix.AdjacencyCount(TriangleNet.Mesh)">
             <summary>
             Counts adjacencies in a triangulation.
             </summary>
             <remarks>
             This routine is called to count the adjacencies, so that the
             appropriate amount of memory can be set aside for storage when
             the adjacency structure is created.
            
             The triangulation is assumed to involve 3-node triangles.
            
             Two nodes are "adjacent" if they are both nodes in some triangle.
             Also, a node is considered to be adjacent to itself.
             </remarks>
        </member>
        <member name="M:TriangleNet.Tools.AdjacencyMatrix.AdjacencySet(TriangleNet.Mesh,System.Int32[])">
            <summary>
            Sets adjacencies in a triangulation.
            </summary>
            <remarks>
            This routine can be used to create the compressed column storage
            for a linear triangle finite element discretization of Poisson's
            equation in two dimensions.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.AdjacencyMatrix.SortIndices">
            <summary>
            Sort indices.
            </summary>
        </member>
        <member name="T:TriangleNet.Tools.CuthillMcKee">
            <summary>
            Applies the Cuthill and McKee renumbering algorithm to reduce the bandwidth of
            the adjacency matrix associated with the mesh.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.Renumber(TriangleNet.Mesh)">
            <summary>
            Gets the permutation vector for the Reverse Cuthill-McKee numbering.
            </summary>
            <param name="mesh">The mesh.</param>
            <returns>Permutation vector.</returns>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.Renumber(TriangleNet.Tools.AdjacencyMatrix)">
            <summary>
            Gets the permutation vector for the Reverse Cuthill-McKee numbering.
            </summary>
            <param name="matrix">The adjacency matrix.</param>
            <returns>Permutation vector.</returns>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.GenerateRcm">
            <summary>
            Finds the reverse Cuthill-Mckee ordering for a general graph.
            </summary>
            <returns>The RCM ordering.</returns>
            <remarks>
            For each connected component in the graph, the routine obtains
            an ordering by calling RCM.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.Rcm(System.Int32,System.Int32[],System.Int32[],System.Int32,System.Int32@)">
             <summary>
             RCM renumbers a connected component by the reverse Cuthill McKee algorithm.
             </summary>
             <param name="root">the node that defines the connected component. It is used as the starting 
             point for the RCM ordering.</param>
             <param name="mask">Input/output, int MASK(NODE_NUM), a mask for the nodes. Only those nodes with 
             nonzero input mask values are considered by the routine. The nodes numbered by RCM will have 
             their mask values set to zero.</param>
             <param name="perm">Output, int PERM(NODE_NUM), the RCM ordering.</param>
             <param name="offset">Internal array offset.</param>
             <param name="iccsze">Output, int ICCSZE, the size of the connected component that has been numbered.</param>
             <remarks>
                The connected component is specified by a node ROOT and a mask.
                The numbering starts at the root node.
            
                An outline of the algorithm is as follows:
            
                X(1) = ROOT.
            
                for ( I = 1 to N-1)
                  Find all unlabeled neighbors of X(I),
                  assign them the next available labels, in order of increasing degree.
            
                When done, reverse the ordering.
             </remarks>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.FindRoot(System.Int32@,System.Int32[],System.Int32@,System.Int32[],System.Int32[],System.Int32)">
             <summary>
             Finds a pseudo-peripheral node.
             </summary>
             <param name="root">On input, ROOT is a node in the the component of the graph for 
             which a pseudo-peripheral node is sought. On output, ROOT is the pseudo-peripheral 
             node obtained.</param>
             <param name="mask">MASK[NODE_NUM], specifies a section subgraph. Nodes for which MASK 
             is zero are ignored by FNROOT.</param>
             <param name="level_num">Output, int LEVEL_NUM, is the number of levels in the level 
             structure rooted at the node ROOT.</param>
             <param name="level_row">Output, int LEVEL_ROW(NODE_NUM+1), the level structure array pair 
             containing the level structure found.</param>
             <param name="level">Output, int LEVEL(NODE_NUM), the level structure array pair 
             containing the level structure found.</param>
             <param name="offset">Internal array offset.</param>
             <remarks>
             The diameter of a graph is the maximum distance (number of edges)
             between any two nodes of the graph.
            
             The eccentricity of a node is the maximum distance between that
             node and any other node of the graph.
            
             A peripheral node is a node whose eccentricity equals the
             diameter of the graph.
            
             A pseudo-peripheral node is an approximation to a peripheral node;
             it may be a peripheral node, but all we know is that we tried our
             best.
            
             The routine is given a graph, and seeks pseudo-peripheral nodes,
             using a modified version of the scheme of Gibbs, Poole and
             Stockmeyer.  It determines such a node for the section subgraph
             specified by MASK and ROOT.
            
             The routine also determines the level structure associated with
             the given pseudo-peripheral node; that is, how far each node
             is from the pseudo-peripheral node.  The level structure is
             returned as a list of nodes LS, and pointers to the beginning
             of the list of nodes that are at a distance of 0, 1, 2, ...,
             NODE_NUM-1 from the pseudo-peripheral node.
            
             Reference:
                Alan George, Joseph Liu,
                Computer Solution of Large Sparse Positive Definite Systems,
                Prentice Hall, 1981.
            
                Norman Gibbs, William Poole, Paul Stockmeyer,
                An Algorithm for Reducing the Bandwidth and Profile of a Sparse Matrix,
                SIAM Journal on Numerical Analysis,
                Volume 13, pages 236-250, 1976.
            
                Norman Gibbs,
                Algorithm 509: A Hybrid Profile Reduction Algorithm,
                ACM Transactions on Mathematical Software,
                Volume 2, pages 378-387, 1976.
             </remarks>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.GetLevelSet(System.Int32@,System.Int32[],System.Int32@,System.Int32[],System.Int32[],System.Int32)">
             <summary>
             Generates the connected level structure rooted at a given node.
             </summary>
             <param name="root">the node at which the level structure is to be rooted.</param>
             <param name="mask">MASK[NODE_NUM]. On input, only nodes with nonzero MASK are to be processed. 
             On output, those nodes which were included in the level set have MASK set to 1.</param>
             <param name="level_num">Output, int LEVEL_NUM, the number of levels in the level structure. ROOT is 
             in level 1.  The neighbors of ROOT are in level 2, and so on.</param>
             <param name="level_row">Output, int LEVEL_ROW[NODE_NUM+1], the rooted level structure.</param>
             <param name="level">Output, int LEVEL[NODE_NUM], the rooted level structure.</param>
             <param name="offset">Internal array offset.</param>
             <remarks>
             Only nodes for which MASK is nonzero will be considered.
            
             The root node chosen by the user is assigned level 1, and masked.
             All (unmasked) nodes reachable from a node in level 1 are
             assigned level 2 and masked.  The process continues until there
             are no unmasked nodes adjacent to any node in the current level.
             The number of levels may vary between 2 and NODE_NUM.
            
             Reference:
                Alan George, Joseph Liu,
                Computer Solution of Large Sparse Positive Definite Systems,
                Prentice Hall, 1981.
             </remarks>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.Degree(System.Int32,System.Int32[],System.Int32[],System.Int32@,System.Int32[],System.Int32)">
             <summary>
             Computes the degrees of the nodes in the connected component.
             </summary>
             <param name="root">the node that defines the connected component.</param>
             <param name="mask">MASK[NODE_NUM], is nonzero for those nodes which are to be considered.</param>
             <param name="deg">Output, int DEG[NODE_NUM], contains, for each  node in the connected component, its degree.</param>
             <param name="iccsze">Output, int ICCSIZE, the number of nodes in the connected component.</param>
             <param name="ls">Output, int LS[NODE_NUM], stores in entries 1 through ICCSIZE the nodes in the 
             connected component, starting with ROOT, and proceeding by levels.</param>
             <param name="offset">Internal array offset.</param>
             <remarks>
                The connected component is specified by MASK and ROOT.
                Nodes for which MASK is zero are ignored.
            
              Reference:
                Alan George, Joseph Liu,
                Computer Solution of Large Sparse Positive Definite Systems,
                Prentice Hall, 1981.
             </remarks>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.PermBandwidth(System.Int32[],System.Int32[])">
            <summary>
            Computes the bandwidth of a permuted adjacency matrix.
            </summary>
            <param name="perm">The permutation.</param>
            <param name="perm_inv">The inverse permutation.</param>
            <returns>Bandwidth of the permuted adjacency matrix.</returns>
            <remarks>
            The matrix is defined by the adjacency information and a permutation.  
            The routine also computes the bandwidth and the size of the envelope.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.PermInverse(System.Int32[])">
            <summary>
            Produces the inverse of a given permutation.
            </summary>
            <param name="perm">PERM[N], a permutation.</param>
            <returns>The inverse permutation.</returns>
        </member>
        <member name="M:TriangleNet.Tools.CuthillMcKee.ReverseVector(System.Int32[],System.Int32,System.Int32)">
             <summary>
             Reverses the elements of an integer vector.
             </summary>
             <param name="size">number of entries in the array.</param>
             <param name="offset">Internal array offset.</param>
             <param name="a">the array to be reversed.</param>
             <example>
               Input:
                 N = 5,
                 A = ( 11, 12, 13, 14, 15 ).
            
               Output:
                 A = ( 15, 14, 13, 12, 11 ).
             </example>
        </member>
        <member name="T:TriangleNet.Tools.Interpolation">
            <summary>
            Interpolation helper.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.Interpolation.InterpolatePoint(TriangleNet.Geometry.ITriangle,TriangleNet.Geometry.Point,System.Double[])">
            <summary>
            Linear interpolation of a point.
            </summary>
            <param name="tri">The triangle containing the point <paramref name="p"/></param>
            <param name="p">The point to interpolate.</param>
            <param name="data">The vertex data (z values).</param>
            <returns>The linear interpolation value.</returns>
            <remarks>
            IMPORTANT: this method assumes the mesh vertex ids correspond to the data array indices.
            </remarks>
        </member>
        <member name="T:TriangleNet.Tools.IntersectionHelper">
            <summary>
            Segment intersection helper.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.IntersectionHelper.IsPointOnSegment(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,System.Double)">
            <summary>
            Check if a given test point lies on a segment.
            </summary>
            <param name="a">The segment start point.</param>
            <param name="b">The segment end point.</param>
            <param name="test">The point to test.</param>
            <param name="eps">Threshold to test collinearity (default = 1e-12).</param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Tools.IntersectionHelper.IntersectSegments(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point@)">
            <summary>
            Compute intersection of two segments.
            </summary>
            <param name="p0">Segment 1 start point.</param>
            <param name="p1">Segment 1 end point.</param>
            <param name="q0">Segment 2 start point.</param>
            <param name="q1">Segment 2 end point.</param>
            <param name="c0">The intersection point.</param>
            <remarks>
            This is a special case of segment intersection. Since the calling algorithm assures
            that a valid intersection exists, there's no need to check for any special cases.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.IntersectionHelper.LiangBarsky(TriangleNet.Geometry.Rectangle,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point@,TriangleNet.Geometry.Point@)">
            <summary>
            Intersect segment with a bounding box.
            </summary>
            <param name="rect">The clip rectangle.</param>
            <param name="p0">Segment endpoint.</param>
            <param name="p1">Segment endpoint.</param>
            <param name="c0">The new location of p0.</param>
            <param name="c1">The new location of p1.</param>
            <returns>Returns true, if segment is clipped.</returns>
            <remarks>
            Based on Liang-Barsky function by Daniel White:
            http://www.skytopia.com/project/articles/compsci/clipping.html
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.IntersectionHelper.BoxRayIntersection(TriangleNet.Geometry.Rectangle,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point@)">
            <summary>
            Intersect a ray with a bounding box.
            </summary>
            <param name="rect">The clip rectangle.</param>
            <param name="p0">The ray start point (inside the box).</param>
            <param name="p1">Any point in ray direction (NOT the direction vector).</param>
            <param name="c1">The intersection point.</param>
            <returns>Returns false, if start point is outside the box.</returns>
        </member>
        <member name="M:TriangleNet.Tools.IntersectionHelper.BoxRayIntersection(TriangleNet.Geometry.Rectangle,TriangleNet.Geometry.Point,System.Double,System.Double)">
            <summary>
            Intersect a ray with a bounding box.
            </summary>
            <param name="rect">The clip rectangle.</param>
            <param name="p">The ray start point (inside the box).</param>
            <param name="dx">X direction.</param>
            <param name="dy">Y direction.</param>
            <returns>Returns false, if start point is outside the box.</returns>
        </member>
        <member name="M:TriangleNet.Tools.IntersectionHelper.BoxRayIntersection(TriangleNet.Geometry.Rectangle,TriangleNet.Geometry.Point,System.Double,System.Double,TriangleNet.Geometry.Point@)">
            <summary>
            Intersect a ray with a bounding box.
            </summary>
            <param name="rect">The clip rectangle.</param>
            <param name="p">The ray startpoint (inside the box).</param>
            <param name="dx">X direction.</param>
            <param name="dy">Y direction.</param>
            <param name="c">The intersection point.</param>
            <returns>Returns false, if startpoint is outside the box.</returns>
        </member>
        <member name="T:TriangleNet.Tools.PolygonValidator">
            <summary>
            Polygon validation helper.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.PolygonValidator.IsConsistent(TriangleNet.Geometry.IPolygon)">
            <summary>
            Test the polygon for consistency.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.PolygonValidator.HasDuplicateVertices(TriangleNet.Geometry.IPolygon)">
            <summary>
            Test the polygon for duplicate vertices.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.PolygonValidator.GetSegmentRatio(TriangleNet.Geometry.IPolygon,System.Double)">
            <summary>
            Gets the minimum and maximum feature size (segment length) of the input polygon.
            </summary>
            <param name="poly">The polygon.</param>
            <param name="threshold">The ratio threshold (smallest to largest segment length, default = 2e-10).</param>
            <remarks>
            This method will also report zero-length segments. The method does NOT detect
            free vertices lying close to segments.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.PolygonValidator.HasBadAngles(TriangleNet.Geometry.IPolygon,System.Double)">
            <summary>
            Test the polygon for 360 degree angles.
            </summary>
            <param name="poly">The polygon.</param>
            <param name="threshold">The angle threshold.</param>
            <remarks>
            This method assumes that segments are stored in order. There may be different,
            unconnected contours in the polygon, but the segments of each contour have to
            be in order to get a meaningful result.
            </remarks>
        </member>
        <member name="T:TriangleNet.Tools.Measure">
            <summary>
            Base class for quality measures.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Measure.Minimum">
            <summary>
            Gets the minimum value of the measure.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Measure.Maximum">
            <summary>
            Gets the maximum value of the measure.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Measure.Average">
            <summary>
            Gets the average value of the measure.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Measure.Area">
            <summary>
            Gets the value averaged over all triangles and weighted by area.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.Measure.Initialize">
            <summary>
            Initialize the measure.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.Measure.Update(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Compute measure of given triangle.
            </summary>
            <param name="ab">Side length ab.</param>
            <param name="bc">Side length bc.</param>
            <param name="ca">Side length ca.</param>
            <param name="area">Triangle area.</param>
        </member>
        <member name="M:TriangleNet.Tools.Measure.Finalize(System.Int32,System.Double)">
            <summary>
            Finalize the measure.
            </summary>
            <param name="n">Total number of triangles measured.</param>
            <param name="totalArea">Total area of triangles measured.</param>
        </member>
        <member name="T:TriangleNet.Tools.QualityMeasure">
            <summary>
            Provides mesh quality information.
            </summary>
            <remarks>
            Given a triangle abc with points A (ax, ay), B (bx, by), C (cx, cy).
            
            The side lengths are given as
              a = sqrt((cx - bx)^2 + (cy - by)^2) -- side BC opposite of A
              b = sqrt((cx - ax)^2 + (cy - ay)^2) -- side CA opposite of B
              c = sqrt((ax - bx)^2 + (ay - by)^2) -- side AB opposite of C
              
            The angles are given as
              ang_a = acos((b^2 + c^2 - a^2)  / (2 * b * c)) -- angle at A
              ang_b = acos((c^2 + a^2 - b^2)  / (2 * c * a)) -- angle at B
              ang_c = acos((a^2 + b^2 - c^2)  / (2 * a * b)) -- angle at C
              
            The semiperimeter is given as
              s = (a + b + c) / 2
              
            The area is given as
              D = abs(ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)) / 2
                = sqrt(s * (s - a) * (s - b) * (s - c))
                 
            The inradius is given as
              r = D / s
              
            The circumradius is given as
              R = a * b * c / (4 * D)
            
            The altitudes are given as
              alt_a = 2 * D / a -- altitude above side a
              alt_b = 2 * D / b -- altitude above side b
              alt_c = 2 * D / c -- altitude above side c
            
            The aspect ratio may be given as the ratio of the longest to the
            shortest edge or, more commonly as the ratio of the circumradius 
            to twice the inradius
              ar = R / (2 * r)
                 = a * b * c / (8 * (s - a) * (s - b) * (s - c))
                 = a * b * c / ((b + c - a) * (c + a - b) * (a + b - c))
            </remarks>
        </member>
        <member name="P:TriangleNet.Tools.QualityMeasure.Area">
            <summary>
            Gets the area measure.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.QualityMeasure.Alpha">
            <summary>
            Gets the alpha measure.
            </summary>
            <remarks>
            The alpha measure computes the minimum angle among all triangles.
            The best possible value is 1, and the worst 0.
            </remarks>
        </member>
        <member name="P:TriangleNet.Tools.QualityMeasure.Eta">
            <summary>
            Gets the eta measure.
            </summary>
            <remarks>
            The eta measure relates the area of a triangle a to its edge lengths.
            The best possible value is 1, and the worst 0.
            </remarks>
        </member>
        <member name="P:TriangleNet.Tools.QualityMeasure.Q">
            <summary>
            Gets the Q measure, also knows as normalized shape ratio (NSR).
            </summary>
            <remarks>
            The Q measure relates the incircle to the circumcircle radius.
            In an ideally regular mesh, all triangles would have the same
            equilateral shape, for which Q = 1.
            </remarks>
        </member>
        <member name="P:TriangleNet.Tools.QualityMeasure.AreaTotal">
            <summary>
            Gets the total triangulation area.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Tools.QualityMeasure" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.Add(TriangleNet.Tools.Measure)">
            <summary>
            Add a custom measure.
            </summary>
            <param name="measure"></param>
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.Update(TriangleNet.Meshing.IMesh)">
            <summary>
            Update all measures for the given mesh.
            </summary>
            <param name="mesh">The mesh.</param>
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.Update(System.Collections.Generic.IEnumerable{TriangleNet.Geometry.ITriangle})">
            <summary>
            Update all measures for the given triangles.
            </summary>
            <param name="triangles">The triangles.</param>
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.Bandwidth(TriangleNet.Meshing.IMesh)">
             <summary>
             Determines the bandwidth of the coefficient matrix.
             </summary>
             <returns>Bandwidth of the coefficient matrix.</returns>
             <remarks>
             The quantity computed here is the "geometric" bandwidth determined
             by the finite element mesh alone.
            
             If a single finite element variable is associated with each node
             of the mesh, and if the nodes and variables are numbered in the
             same way, then the geometric bandwidth is the same as the bandwidth
             of a typical finite element matrix.
            
             The bandwidth M is defined in terms of the lower and upper bandwidths:
            
               M = ML + 1 + MU
            
             where 
            
               ML = maximum distance from any diagonal entry to a nonzero
               entry in the same row, but earlier column,
            
               MU = maximum distance from any diagonal entry to a nonzero
               entry in the same row, but later column.
            
             Because the finite element node adjacency relationship is symmetric,
             we are guaranteed that ML = MU.
             
             Based on Matlab code by John Burkardt, Florida State University.
             </remarks>
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.MeasureArea.Initialize">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.MeasureArea.Update(System.Double,System.Double,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.MeasureArea.Finalize(System.Int32,System.Double)">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Tools.QualityMeasure.MeasureAlpha">
             <summary>
             The alpha measure determines the triangulated point set quality.
             </summary>
             <remarks>
             The alpha measure evaluates the uniformity of the shapes of the triangles
             defined by a triangulated point set.
            
             We compute the minimum angle among all the triangles in the triangulated
             dataset and divide by the maximum possible value (which, in degrees,
             is 60). The best possible value is 1, and the worst 0. A good
             triangulation should have an alpha score close to 1.
             </remarks>
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.MeasureAlpha.Update(System.Double,System.Double,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Tools.QualityMeasure.MeasureEta">
             <summary>
             The eta measure determines the triangulated point set quality.
             </summary>
             <remarks>
             The eta measure evaluates the uniformity of the shapes of the triangles
             defined by a triangulated point set.
            
             The measure relates the area of a triangle a to its edge lengths. The best
             possible value is 1, and the worst 0. A good triangulation should have an
             eta score close to 1.
             </remarks>
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.MeasureEta.Update(System.Double,System.Double,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Tools.QualityMeasure.MeasureQ">
             <summary>
             The Q measure determines the triangulated point set quality.
             </summary>
             <remarks>
             The Q measure evaluates the uniformity of the shapes of the triangles
             defined by a triangulated point set. It uses the aspect ratio
            
                2 * (incircle radius) / (circumcircle radius)
            
             In an ideally regular mesh, all triangles would have the same
             equilateral shape, for which Q = 1. A good mesh would have
             0.5 &lt; Q.
             </remarks>
        </member>
        <member name="M:TriangleNet.Tools.QualityMeasure.MeasureQ.Update(System.Double,System.Double,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Tools.Statistic">
            <summary>
            Gather mesh statistics.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.Statistic.InCircleCount">
            <summary>
            Number of incircle tests performed.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.Statistic.InCircleAdaptCount">
            <summary>
            Number of adaptive incircle tests performed.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.Statistic.CounterClockwiseCount">
            <summary>
            Number of counterclockwise tests performed.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.Statistic.CounterClockwiseAdaptCount">
            <summary>
            Number of adaptive counterclockwise tests performed.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.Statistic.Orient3dCount">
            <summary>
            Number of 3D orientation tests performed.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.Statistic.HyperbolaCount">
            <summary>
            Number of right-of-hyperbola tests performed.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.Statistic.CircumcenterCount">
            <summary>
            // Number of circumcenter calculations performed.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.Statistic.CircleTopCount">
            <summary>
            Number of circle top calculations performed.
            </summary>
        </member>
        <member name="F:TriangleNet.Tools.Statistic.RelocationCount">
            <summary>
            Number of vertex relocations.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.ShortestEdge">
            <summary>
            Gets the shortest edge.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.LongestEdge">
            <summary>
            Gets the longest edge.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.ShortestAltitude">
            <summary>
            Gets the shortest altitude.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.LargestAspectRatio">
            <summary>
            Gets the largest aspect ratio.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.SmallestArea">
            <summary>
            Gets the smallest area.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.LargestArea">
            <summary>
            Gets the largest area.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.SmallestAngle">
            <summary>
            Gets the smallest angle.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.LargestAngle">
            <summary>
            Gets the largest angle.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.AngleHistogram">
            <summary>
            Gets the angle histogram.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.MinAngleHistogram">
            <summary>
            Gets the min angles histogram.
            </summary>
        </member>
        <member name="P:TriangleNet.Tools.Statistic.MaxAngleHistogram">
            <summary>
            Gets the max angles histogram.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.Statistic.Update(TriangleNet.Mesh,System.Int32)">
            <summary>
            Update statistics about the quality of the mesh.
            </summary>
            <param name="mesh"></param>
            <param name="sampleDegrees">Number of degrees to sample
            (currently fixed to 60 = sample every 3 degrees).</param>
        </member>
        <member name="M:TriangleNet.Tools.Statistic.ComputeAngles(TriangleNet.Geometry.ITriangle,System.Double[])">
            <summary>
            Compute angle information for given triangle.
            </summary>
            <param name="triangle">The triangle to check.</param>
            <param name="data">Array of doubles (length 6).</param>
            <remarks>
            On return, the squared cosines of the minimum and maximum angle will
            be stored at position data[0] and data[1] respectively.
            If the triangle was obtuse, data[2] will be set to -1 and maximum angle
            is computed as (pi - acos(sqrt(data[1]))).
            </remarks>
        </member>
        <member name="T:TriangleNet.Tools.TriangleQuadTree">
            <summary>
            A Quadtree implementation optimized for triangles.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.TriangleQuadTree.#ctor(TriangleNet.Mesh,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Tools.TriangleQuadTree" /> class.
            </summary>
            <param name="mesh">Mesh containing triangles.</param>
            <param name="maxDepth">The maximum depth of the tree.</param>
            <param name="sizeBound">The maximum number of triangles contained in a leaf.</param>
            <remarks>
            The quadtree does not track changes of the mesh. If a mesh is refined or
            changed in any other way, a new quadtree has to be built to make the point
            location work.
            
            A node of the tree will be split, if its level if less than the max depth parameter
            AND the number of triangles in the node is greater than the size bound.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.TriangleQuadTree.Query(System.Double,System.Double)">
            <summary>
            Query the quadtree a given point.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Tools.TriangleQuadTree.IsPointInTriangle(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point)">
            <summary>
            Test, if a given point lies inside a triangle.
            </summary>
            <param name="p">Point to locate.</param>
            <param name="t0">Corner point of triangle.</param>
            <param name="t1">Corner point of triangle.</param>
            <param name="t2">Corner point of triangle.</param>
            <returns>True, if point is inside or on the edge of this triangle.</returns>
        </member>
        <member name="T:TriangleNet.Tools.TriangleQuadTree.QuadNode">
            <summary>
            A node of the quadtree.
            </summary>
        </member>
        <member name="T:TriangleNet.Tools.VertexSorter">
            <summary>
            Sort an array of points using quicksort.
            </summary>
        </member>
        <member name="M:TriangleNet.Tools.VertexSorter.Sort(TriangleNet.Geometry.Vertex[],System.Int32)">
            <summary>
            Sorts the given vertex array by x-coordinate.
            </summary>
            <param name="array">The vertex array.</param>
            <param name="seed">Random seed used for pivoting.</param>
        </member>
        <member name="M:TriangleNet.Tools.VertexSorter.Alternate(TriangleNet.Geometry.Vertex[],System.Int32,System.Int32)">
            <summary>
            Impose alternating cuts on given vertex array.
            </summary>
            <param name="array">The vertex array.</param>
            <param name="length">The number of vertices to sort.</param>
            <param name="seed">Random seed used for pivoting.</param>
        </member>
        <member name="M:TriangleNet.Tools.VertexSorter.QuickSort(System.Int32,System.Int32)">
            <summary>
            Sort an array of vertices by x-coordinate, using the y-coordinate as a secondary key.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <remarks>
            Uses quicksort. Randomized O(n log n) time. No, I did not make any of
            the usual quicksort mistakes.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.VertexSorter.AlternateAxes(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the vertices as appropriate for the divide-and-conquer algorithm with 
            alternating cuts.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="axis"></param>
            <remarks>
            Partitions by x-coordinate if axis == 0; by y-coordinate if axis == 1.
            For the base case, subsets containing only two or three vertices are
            always sorted by x-coordinate.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.VertexSorter.VertexMedianX(System.Int32,System.Int32,System.Int32)">
            <summary>
            An order statistic algorithm, almost. Shuffles an array of vertices so that the
            first 'median' vertices occur lexicographically before the remaining vertices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="median"></param>
            <remarks>
            Uses the x-coordinate as the primary key. Very similar to the QuickSort()
            procedure, but runs in randomized linear time.
            </remarks>
        </member>
        <member name="M:TriangleNet.Tools.VertexSorter.VertexMedianY(System.Int32,System.Int32,System.Int32)">
            <summary>
            An order statistic algorithm, almost.  Shuffles an array of vertices so that 
            the first 'median' vertices occur lexicographically before the remaining vertices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="median"></param>
            <remarks>
            Uses the y-coordinate as the primary key. Very similar to the QuickSort()
            procedure, but runs in randomized linear time.
            </remarks>
        </member>
        <member name="T:TriangleNet.Topology.DCEL.DcelMesh">
            <summary>
            DCEL mesh.
            </summary>
        </member>
        <member name="F:TriangleNet.Topology.DCEL.DcelMesh.vertices">
            <summary>List of vertices.</summary>
        </member>
        <member name="F:TriangleNet.Topology.DCEL.DcelMesh.edges">
            <summary>List of half-edges.</summary>
        </member>
        <member name="F:TriangleNet.Topology.DCEL.DcelMesh.faces">
            <summary>List of faces.</summary>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.DcelMesh.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.DCEL.DcelMesh" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.DcelMesh.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.DCEL.DcelMesh" /> class.
            </summary>
            <param name="initialize">If false, lists will not be initialized.</param>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.DcelMesh.Vertices">
            <summary>
            Gets the vertices of the Voronoi diagram.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.DcelMesh.HalfEdges">
            <summary>
            Gets the list of half-edges specify the Voronoi diagram topology.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.DcelMesh.Faces">
            <summary>
            Gets the faces of the Voronoi diagram.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.DcelMesh.Edges">
            <summary>
            Gets the collection of edges of the Voronoi diagram.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.DcelMesh.IsConsistent(System.Boolean,System.Int32)">
            <summary>
            Check if the DCEL is consistent.
            </summary>
            <param name="closed">If true, faces are assumed to be closed (i.e. all edges must have
            a valid next pointer).</param>
            <param name="depth">Maximum edge count of faces (default = 0 means skip check).</param>
            <returns></returns>
            <remarks>
            The <paramref name="depth"/> value relates to the maximum degree of a vertex in the
            triangulation. For quality meshes, the maximum degree is usually low, but for meshes
            build from PSLGs without quality constraints applied, either provide a larger value
            or disable the check by setting <paramref name="depth"/> to 0 (default).
            </remarks>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.DcelMesh.ResolveBoundaryEdges">
            <summary>
            Search for half-edge without twin and add a twin. Connect twins to form connected
            boundary contours.
            </summary>
            <remarks>
            This method assumes that all faces are closed (i.e. no edge.next pointers are null).
            </remarks>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.DcelMesh.EnumerateEdges">
            <summary>
            Enumerates all edges of the DCEL.
            </summary>
            <remarks>
            This method assumes that each half-edge has a twin (i.e. NOT null).
            </remarks>
        </member>
        <member name="T:TriangleNet.Topology.DCEL.Face">
            <summary>
            A face of the DCEL datastructure.
            </summary>
        </member>
        <member name="F:TriangleNet.Topology.DCEL.Face.Empty">
            <summary>
            A face representing "outer space".
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.Face.Generator">
            <summary>
            If part of a Voronoi diagram, returns the generator vertex
            of the face. Otherwise <c>null</c>.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.Face.ID">
            <summary>
            Gets or sets the face id.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.Face.Edge">
            <summary>
            Gets or sets a half-edge connected to the face.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.Face.Bounded">
            <summary>
            Gets or sets a value, indicating if the face is bounded (for Voronoi diagram).
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.Face.#ctor(TriangleNet.Geometry.Point)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.DCEL.Face" /> class.
            </summary>
            <param name="generator">The generator of this face (for Voronoi diagram)</param>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.Face.#ctor(TriangleNet.Geometry.Point,TriangleNet.Topology.DCEL.HalfEdge)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.DCEL.Face" /> class.
            </summary>
            <param name="generator">The generator of this face (for Voronoi diagram)</param>
            <param name="edge">The half-edge connected to this face.</param>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.Face.EnumerateEdges">
            <summary>
            Enumerates all half-edges of the face boundary.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.Face.ToString">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Topology.DCEL.HalfEdge">
            <summary>
            A half-edge of the DCEL datastructure.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.HalfEdge.ID">
            <summary>
            Gets or sets the half-edge id.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.HalfEdge.Boundary">
            <summary>
            Gets or sets a boundary marker.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.HalfEdge.Origin">
            <summary>
            Gets or sets the origin of the half-edge.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.HalfEdge.Face">
            <summary>
            Gets or sets the face connected to the half-edge.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.HalfEdge.Twin">
            <summary>
            Gets or sets the twin of the half-edge.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.HalfEdge.Next">
            <summary>
            Gets or sets the next pointer of the half-edge.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.HalfEdge.#ctor(TriangleNet.Topology.DCEL.Vertex)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.DCEL.HalfEdge" /> class.
            </summary>
            <param name="origin">The origin of this half-edge.</param>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.HalfEdge.#ctor(TriangleNet.Topology.DCEL.Vertex,TriangleNet.Topology.DCEL.Face)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.DCEL.HalfEdge" /> class.
            </summary>
            <param name="origin">The origin of this half-edge.</param>
            <param name="face">The face connected to this half-edge.</param>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.HalfEdge.ToString">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Topology.DCEL.Vertex">
            <summary>
            A vertex of the DCEL datastructure.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.DCEL.Vertex.Leaving">
            <summary>
            Gets or sets a half-edge leaving the vertex.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.Vertex.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.DCEL.Vertex" /> class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.Vertex.#ctor(System.Double,System.Double,TriangleNet.Topology.DCEL.HalfEdge)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.DCEL.Vertex" /> class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="leaving">A half-edge leaving this vertex.</param>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.Vertex.EnumerateEdges">
            <summary>
            Enumerates all half-edges leaving this vertex.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Topology.DCEL.Vertex.ToString">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Topology.Osub">
            <summary>
            An oriented subsegment.
            </summary>
            <remarks>
            Includes a pointer to a subsegment and an orientation. The orientation denotes a
            side of the edge. Hence, there are two possible orientations. By convention, the
            edge is always directed so that the "side" denoted is the right side of the edge.
            </remarks>
        </member>
        <member name="P:TriangleNet.Topology.Osub.Segment">
            <summary>
            Gets the subsegment.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.ToString">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Topology.Osub.Sym(TriangleNet.Topology.Osub@)">
            <summary>
            Reverse the orientation of a subsegment. [sym(ab) -> ba]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Sym">
            <summary>
            Reverse the orientation of a subsegment. [sym(ab) -> ba]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Pivot(TriangleNet.Topology.Osub@)">
            <summary>
            Find adjoining subsegment with the same origin. [pivot(ab) -> a*]
            </summary>
            <remarks>spivot() finds the other subsegment (from the same segment) 
            that shares the same origin.
            </remarks>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Pivot(TriangleNet.Topology.Otri@)">
            <summary>
            Finds a triangle abutting a subsegment.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Next(TriangleNet.Topology.Osub@)">
            <summary>
            Find next subsegment in sequence. [next(ab) -> b*]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Next">
            <summary>
            Find next subsegment in sequence. [next(ab) -> b*]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Org">
            <summary>
            Get the origin of a subsegment
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Dest">
            <summary>
            Get the destination of a subsegment
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.SetOrg(TriangleNet.Geometry.Vertex)">
            <summary>
            Set the origin or destination of a subsegment.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.SetDest(TriangleNet.Geometry.Vertex)">
            <summary>
            Set destination of a subsegment.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.SegOrg">
            <summary>
            Get the origin of the segment that includes the subsegment.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.SegDest">
            <summary>
            Get the destination of the segment that includes the subsegment.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.SetSegOrg(TriangleNet.Geometry.Vertex)">
            <summary>
            Set the origin of the segment that includes the subsegment.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.SetSegDest(TriangleNet.Geometry.Vertex)">
            <summary>
            Set the destination of the segment that includes the subsegment.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Bond(TriangleNet.Topology.Osub@)">
            <summary>
            Bond two subsegments together. [bond(abc, ba)]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Dissolve(TriangleNet.Topology.SubSegment)">
            <summary>
            Dissolve a subsegment bond (from one side).
            </summary>
            <remarks>Note that the other subsegment will still think it's 
            connected to this subsegment.</remarks>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Equal(TriangleNet.Topology.Osub)">
            <summary>
            Test for equality of subsegments.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.TriDissolve(TriangleNet.Topology.Triangle)">
            <summary>
            Dissolve a bond (from the subsegment side).
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.IsDead(TriangleNet.Topology.SubSegment)">
            <summary>
            Check a subsegment's deallocation.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Osub.Kill(TriangleNet.Topology.SubSegment)">
            <summary>
            Set a subsegment's deallocation.
            </summary>
        </member>
        <member name="T:TriangleNet.Topology.Otri">
            <summary>
            An oriented triangle.
            </summary>
            <remarks>
            Includes a pointer to a triangle and orientation.  The orientation denotes an edge
            of the triangle. Hence, there are three possible orientations. By convention, each
            edge always points counterclockwise about the corresponding triangle.
            </remarks>
        </member>
        <member name="P:TriangleNet.Topology.Otri.Triangle">
            <summary>
            Gets or sets the triangle.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.ToString">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Topology.Otri.Sym(TriangleNet.Topology.Otri@)">
            <summary>
            Find the abutting triangle; same edge. [sym(abc) -> ba*]
            </summary>
            <remarks>
            Note that the edge direction is necessarily reversed, because the handle specified 
            by an oriented triangle is directed counterclockwise around the triangle.
            </remarks>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Sym">
            <summary>
            Find the abutting triangle; same edge. [sym(abc) -> ba*]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Lnext(TriangleNet.Topology.Otri@)">
            <summary>
            Find the next edge (counterclockwise) of a triangle. [lnext(abc) -> bca]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Lnext">
            <summary>
            Find the next edge (counterclockwise) of a triangle. [lnext(abc) -> bca]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Lprev(TriangleNet.Topology.Otri@)">
            <summary>
            Find the previous edge (clockwise) of a triangle. [lprev(abc) -> cab]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Lprev">
            <summary>
            Find the previous edge (clockwise) of a triangle. [lprev(abc) -> cab]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Onext(TriangleNet.Topology.Otri@)">
            <summary>
            Find the next edge counterclockwise with the same origin. [onext(abc) -> ac*]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Onext">
            <summary>
            Find the next edge counterclockwise with the same origin. [onext(abc) -> ac*]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Oprev(TriangleNet.Topology.Otri@)">
            <summary>
            Find the next edge clockwise with the same origin. [oprev(abc) -> a*b]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Oprev">
            <summary>
            Find the next edge clockwise with the same origin. [oprev(abc) -> a*b]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Dnext(TriangleNet.Topology.Otri@)">
            <summary>
            Find the next edge counterclockwise with the same destination. [dnext(abc) -> *ba]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Dnext">
            <summary>
            Find the next edge counterclockwise with the same destination. [dnext(abc) -> *ba]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Dprev(TriangleNet.Topology.Otri@)">
            <summary>
            Find the next edge clockwise with the same destination. [dprev(abc) -> cb*]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Dprev">
            <summary>
            Find the next edge clockwise with the same destination. [dprev(abc) -> cb*]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Rnext(TriangleNet.Topology.Otri@)">
            <summary>
            Find the next edge (counterclockwise) of the adjacent triangle. [rnext(abc) -> *a*]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Rnext">
            <summary>
            Find the next edge (counterclockwise) of the adjacent triangle. [rnext(abc) -> *a*]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Rprev(TriangleNet.Topology.Otri@)">
            <summary>
            Find the previous edge (clockwise) of the adjacent triangle. [rprev(abc) -> b**]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Rprev">
            <summary>
            Find the previous edge (clockwise) of the adjacent triangle. [rprev(abc) -> b**]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Org">
            <summary>
            Origin [org(abc) -> a]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Dest">
            <summary>
            Destination [dest(abc) -> b]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Apex">
            <summary>
            Apex [apex(abc) -> c]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Copy(TriangleNet.Topology.Otri@)">
            <summary>
            Copy an oriented triangle.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Pivot(TriangleNet.Topology.Osub@)">
            <summary>
            Finds a subsegment abutting a triangle.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Equals(TriangleNet.Topology.Otri)">
            <summary>
            Test for equality of oriented triangles.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.SetOrg(TriangleNet.Geometry.Vertex)">
            <summary>
            Set Origin
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.SetDest(TriangleNet.Geometry.Vertex)">
            <summary>
            Set Destination
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.SetApex(TriangleNet.Geometry.Vertex)">
            <summary>
            Set Apex
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Bond(TriangleNet.Topology.Otri@)">
            <summary>
            Bond two triangles together at the resepective handles. [bond(abc, bad)]
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Dissolve(TriangleNet.Topology.Triangle)">
            <summary>
            Dissolve a bond (from one side).  
            </summary>
            <remarks>Note that the other triangle will still think it's connected to 
            this triangle. Usually, however, the other triangle is being deleted 
            entirely, or bonded to another triangle, so it doesn't matter.
            </remarks>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Infect">
            <summary>
            Infect a triangle with the virus.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Uninfect">
            <summary>
            Cure a triangle from the virus.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.IsInfected">
            <summary>
            Test a triangle for viral infection.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.SegBond(TriangleNet.Topology.Osub@)">
            <summary>
            Bond a triangle to a subsegment.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.SegDissolve(TriangleNet.Topology.SubSegment)">
            <summary>
            Dissolve a bond (from the triangle side).
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.IsDead(TriangleNet.Topology.Triangle)">
            <summary>
            Check a triangle's deallocation.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Otri.Kill(TriangleNet.Topology.Triangle)">
            <summary>
            Set a triangle's deallocation.
            </summary>
        </member>
        <member name="T:TriangleNet.Topology.SubSegment">
            <summary>
            The subsegment data structure.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.SubSegment.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.SubSegment" /> class.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.SubSegment.P0">
            <summary>
            Gets the first endpoints vertex id.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.SubSegment.P1">
            <summary>
            Gets the seconds endpoints vertex id.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.SubSegment.Label">
            <summary>
            Gets the segment boundary mark.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.SubSegment.GetVertex(System.Int32)">
            <summary>
            Gets the segments endpoint.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.SubSegment.GetTriangle(System.Int32)">
            <summary>
            Gets an adjoining triangle.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.SubSegment.GetTriangle(System.Int32,TriangleNet.Topology.Otri@)">
            <summary>
            Gets an adjoining triangle.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.SubSegment.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Topology.SubSegment.ToString">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Topology.Triangle">
            <summary>
            The triangle data structure.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Triangle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Topology.Triangle" /> class.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.Triangle.ID">
            <summary>
            Gets or sets the triangle id.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.Triangle.Label">
            <summary>
            Region ID the triangle belongs to.
            </summary>
        </member>
        <member name="P:TriangleNet.Topology.Triangle.Area">
            <summary>
            Gets the triangle area constraint.
            </summary>
        </member>
        <member name="M:TriangleNet.Topology.Triangle.GetVertex(System.Int32)">
            <summary>
            Gets the specified corners vertex.
            </summary>
            <param name="index">The corner index (0, 1 or 2).</param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Topology.Triangle.GetVertexID(System.Int32)">
            <summary>
            Gets the specified corners vertex id.
            </summary>
            <param name="index">The corner index (0, 1 or 2).</param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Topology.Triangle.GetNeighbor(System.Int32)">
            <summary>
            Gets a triangles' neighbor.
            </summary>
            <param name="index">The neighbor index (0, 1 or 2).</param>
            <returns>The neigbbor opposite of vertex with given index.</returns>
        </member>
        <member name="M:TriangleNet.Topology.Triangle.GetNeighborID(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Topology.Triangle.GetSegment(System.Int32)">
            <summary>
            Gets a triangles segment.
            </summary>
            <param name="index">The vertex index (0, 1 or 2).</param>
            <returns>The segment opposite of vertex with given index.</returns>
        </member>
        <member name="M:TriangleNet.Topology.Triangle.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Topology.Triangle.ToString">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.TriangleLocator">
            <summary>
            Locate triangles in a mesh.
            </summary>
            <remarks>
            WARNING: This routine is designed for convex triangulations, and will
            not generally work after the holes and concavities have been carved.
            
            Based on a paper by Ernst P. Mucke, Isaac Saias, and Binhai Zhu, "Fast
            Randomized Point Location Without Preprocessing in Two- and Three-Dimensional
            Delaunay Triangulations," Proceedings of the Twelfth Annual Symposium on
            Computational Geometry, ACM, May 1996.
            </remarks>
        </member>
        <member name="M:TriangleNet.TriangleLocator.#ctor(TriangleNet.Mesh,TriangleNet.IPredicates,System.Random)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.TriangleLocator" /> class.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="predicates">The predicates.</param>
            <param name="random">The random source used in <see cref="T:TriangleNet.TriangleSampler" />.</param>
        </member>
        <member name="M:TriangleNet.TriangleLocator.Update(TriangleNet.Topology.Otri@)">
            <summary>
            Suggest the given triangle as a starting triangle for point location.
            </summary>
            <param name="otri"></param>
        </member>
        <member name="M:TriangleNet.TriangleLocator.PreciseLocate(TriangleNet.Geometry.Point,TriangleNet.Topology.Otri@,System.Boolean)">
             <summary>
             Find a triangle or edge containing a given point.
             </summary>
             <param name="searchpoint">The point to locate.</param>
             <param name="searchtri">The triangle to start the search at.</param>
             <param name="stopatsubsegment"> If 'stopatsubsegment' is set, the search 
             will stop if it tries to walk through a subsegment, and will return OUTSIDE.</param>
             <returns>Location information.</returns>
             <remarks>
             Begins its search from 'searchtri'. It is important that 'searchtri'
             be a handle with the property that 'searchpoint' is strictly to the left
             of the edge denoted by 'searchtri', or is collinear with that edge and
             does not intersect that edge. (In particular, 'searchpoint' should not
             be the origin or destination of that edge.)
            
             These conditions are imposed because preciselocate() is normally used in
             one of two situations:
            
             (1)  To try to find the location to insert a new point.  Normally, we
                  know an edge that the point is strictly to the left of. In the
                  incremental Delaunay algorithm, that edge is a bounding box edge.
                  In Ruppert's Delaunay refinement algorithm for quality meshing,
                  that edge is the shortest edge of the triangle whose circumcenter
                  is being inserted.
            
             (2)  To try to find an existing point.  In this case, any edge on the
                  convex hull is a good starting edge. You must screen out the
                  possibility that the vertex sought is an endpoint of the starting
                  edge before you call preciselocate().
            
             On completion, 'searchtri' is a triangle that contains 'searchpoint'.
            
             This implementation differs from that given by Guibas and Stolfi.  It
             walks from triangle to triangle, crossing an edge only if 'searchpoint'
             is on the other side of the line containing that edge. After entering
             a triangle, there are two edges by which one can leave that triangle.
             If both edges are valid ('searchpoint' is on the other side of both
             edges), one of the two is chosen by drawing a line perpendicular to
             the entry edge (whose endpoints are 'forg' and 'fdest') passing through
             'fapex'. Depending on which side of this perpendicular 'searchpoint'
             falls on, an exit edge is chosen.
            
             This implementation is empirically faster than the Guibas and Stolfi
             point location routine (which I originally used), which tends to spiral
             in toward its target.
            
             Returns ONVERTEX if the point lies on an existing vertex. 'searchtri'
             is a handle whose origin is the existing vertex.
            
             Returns ONEDGE if the point lies on a mesh edge. 'searchtri' is a
             handle whose primary edge is the edge on which the point lies.
            
             Returns INTRIANGLE if the point lies strictly within a triangle.
             'searchtri' is a handle on the triangle that contains the point.
            
             Returns OUTSIDE if the point lies outside the mesh. 'searchtri' is a
             handle whose primary edge the point is to the right of.  This might
             occur when the circumcenter of a triangle falls just slightly outside
             the mesh due to floating-point roundoff error. It also occurs when
             seeking a hole or region point that a foolish user has placed outside
             the mesh.
            
             WARNING:  This routine is designed for convex triangulations, and will
             not generally work after the holes and concavities have been carved.
             However, it can still be used to find the circumcenter of a triangle, as
             long as the search is begun from the triangle in question.</remarks>
        </member>
        <member name="M:TriangleNet.TriangleLocator.Locate(TriangleNet.Geometry.Point,TriangleNet.Topology.Otri@)">
             <summary>
             Find a triangle or edge containing a given point.
             </summary>
             <param name="searchpoint">The point to locate.</param>
             <param name="searchtri">The triangle to start the search at.</param>
             <returns>Location information.</returns>
             <remarks>
             Searching begins from one of:  the input 'searchtri', a recently
             encountered triangle 'recenttri', or from a triangle chosen from a
             random sample. The choice is made by determining which triangle's
             origin is closest to the point we are searching for. Normally,
             'searchtri' should be a handle on the convex hull of the triangulation.
            
             Details on the random sampling method can be found in the Mucke, Saias,
             and Zhu paper cited in the header of this code.
            
             On completion, 'searchtri' is a triangle that contains 'searchpoint'.
            
             Returns ONVERTEX if the point lies on an existing vertex. 'searchtri'
             is a handle whose origin is the existing vertex.
            
             Returns ONEDGE if the point lies on a mesh edge. 'searchtri' is a
             handle whose primary edge is the edge on which the point lies.
            
             Returns INTRIANGLE if the point lies strictly within a triangle.
             'searchtri' is a handle on the triangle that contains the point.
            
             Returns OUTSIDE if the point lies outside the mesh. 'searchtri' is a
             handle whose primary edge the point is to the right of.  This might
             occur when the circumcenter of a triangle falls just slightly outside
             the mesh due to floating-point roundoff error. It also occurs when
             seeking a hole or region point that a foolish user has placed outside
             the mesh.
            
             WARNING:  This routine is designed for convex triangulations, and will
             not generally work after the holes and concavities have been carved.
             </remarks>
        </member>
        <member name="T:TriangleNet.TrianglePool">
            <summary>
            Pool datastructure storing triangles of a <see cref="T:TriangleNet.Mesh" />.
            </summary>
        </member>
        <member name="P:TriangleNet.TrianglePool.Capacity">
            <summary>
            Gets the total number of currently allocated triangles.
            </summary>
        </member>
        <member name="M:TriangleNet.TrianglePool.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.TrianglePool" /> class.
            </summary>
        </member>
        <member name="M:TriangleNet.TrianglePool.Get">
            <summary>
            Gets a triangle from the pool.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.TrianglePool.Release(TriangleNet.Topology.Triangle)">
            <summary>
            Release triangle (making it a free triangle).
            </summary>
        </member>
        <member name="M:TriangleNet.TrianglePool.Restart">
            <summary>
            Restart the triangle pool.
            </summary>
        </member>
        <member name="M:TriangleNet.TrianglePool.Sample(System.Int32,System.Random)">
            <summary>
            Samples a number of triangles from the pool.
            </summary>
            <param name="k">The number of triangles to sample.</param>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.TrianglePool.Add(TriangleNet.Topology.Triangle)">
            <summary>
            Not supported for this <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
        </member>
        <member name="M:TriangleNet.TrianglePool.Clear">
            <summary>
            Clear the pool.
            </summary>
        </member>
        <member name="M:TriangleNet.TrianglePool.Contains(TriangleNet.Topology.Triangle)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.TrianglePool.CopyTo(TriangleNet.Topology.Triangle[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:TriangleNet.TrianglePool.Count">
            <inheritdoc />
        </member>
        <member name="P:TriangleNet.TrianglePool.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.TrianglePool.Remove(TriangleNet.Topology.Triangle)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.TrianglePool.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.TriangleSampler">
            <summary>
            Used for triangle sampling in the <see cref="T:TriangleNet.TriangleLocator"/> class.
            </summary>
        </member>
        <member name="M:TriangleNet.TriangleSampler.Reset">
            <summary>
            Reset the sampler.
            </summary>
        </member>
        <member name="M:TriangleNet.TriangleSampler.Update">
            <summary>
            Update sampling parameters if mesh changed.
            </summary>
        </member>
        <member name="T:TriangleNet.Voronoi.BoundedVoronoi">
            <summary>
            Computing the bounded Voronoi diagram of a constrained and conforming Delaunay triangulation.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.BoundedVoronoi.#ctor(TriangleNet.Mesh)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Voronoi.StandardVoronoi" /> class.
            </summary>
            <param name="mesh">The mesh.</param>
        </member>
        <member name="M:TriangleNet.Voronoi.BoundedVoronoi.#ctor(TriangleNet.Mesh,TriangleNet.Voronoi.IVoronoiFactory,TriangleNet.IPredicates)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Voronoi.StandardVoronoi" /> class.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="factory"></param>
            <param name="predicates"></param>
        </member>
        <member name="M:TriangleNet.Voronoi.BoundedVoronoi.PostProcess">
            <summary>
            Computes edge intersections with mesh boundary edges.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.BoundedVoronoi.HandleCase1(TriangleNet.Topology.DCEL.HalfEdge,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex)">
            <summary>
            Case 1: edge origin lies inside the domain.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.BoundedVoronoi.HandleCase2(TriangleNet.Topology.DCEL.HalfEdge,TriangleNet.Geometry.Vertex,TriangleNet.Geometry.Vertex)">
            <summary>
            Case 2: edge origin lies outside the domain.
            </summary>
        </member>
        <member name="T:TriangleNet.Voronoi.DefaultVoronoiFactory">
            <summary>
            Default factory for Voronoi / DCEL mesh objects.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.DefaultVoronoiFactory.Initialize(System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Voronoi.DefaultVoronoiFactory.Reset">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Voronoi.DefaultVoronoiFactory.CreateVertex(System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Voronoi.DefaultVoronoiFactory.CreateHalfEdge(TriangleNet.Topology.DCEL.Vertex,TriangleNet.Topology.DCEL.Face)">
            <inheritdoc />
        </member>
        <member name="M:TriangleNet.Voronoi.DefaultVoronoiFactory.CreateFace(TriangleNet.Geometry.Vertex)">
            <inheritdoc />
        </member>
        <member name="T:TriangleNet.Voronoi.IVoronoiFactory">
            <summary>
            Factory for Voronoi DCEL datastructure.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.IVoronoiFactory.Initialize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initialize object pool.
            </summary>
            <param name="vertexCount"></param>
            <param name="edgeCount"></param>
            <param name="faceCount"></param>
        </member>
        <member name="M:TriangleNet.Voronoi.IVoronoiFactory.Reset">
            <summary>
            Reset object pool.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.IVoronoiFactory.CreateVertex(System.Double,System.Double)">
            <summary>
            Return a <see cref="T:TriangleNet.Topology.DCEL.Vertex" />.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Voronoi.IVoronoiFactory.CreateHalfEdge(TriangleNet.Topology.DCEL.Vertex,TriangleNet.Topology.DCEL.Face)">
            <summary>
            Return a <see cref="T:TriangleNet.Topology.DCEL.HalfEdge" />.
            </summary>
            <param name="origin"></param>
            <param name="face"></param>
            <returns></returns>
        </member>
        <member name="M:TriangleNet.Voronoi.IVoronoiFactory.CreateFace(TriangleNet.Geometry.Vertex)">
            <summary>
            Return a <see cref="T:TriangleNet.Topology.DCEL.Face" />.
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="T:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy">
            <summary>
            The Bounded Voronoi Diagram is the dual of a PSLG triangulation.
            </summary>
            <remarks>
            2D Centroidal Voronoi Tessellations with Constraints, 2010,
            Jane Tournois, Pierre Alliez and Olivier Devillers
            </remarks>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy.#ctor(TriangleNet.Mesh)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy" /> class.
            </summary>
            <param name="mesh">Mesh instance.</param>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy.#ctor(TriangleNet.Mesh,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy" /> class.
            </summary>
            <param name="mesh">Mesh instance.</param>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy.Points">
            <summary>
            Gets the list of Voronoi vertices.
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy.Regions">
            <summary>
            Gets the list of Voronoi regions.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy.Generate">
            <summary>
            Computes the bounded voronoi diagram.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy.TagBlindTriangles">
            <summary>
            Tag all blind triangles.
            </summary>
            <remarks>
            A triangle is said to be blind if the triangle and its circumcenter
            lie on two different sides of a constrained edge.
            </remarks>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy.TriangleIsBlinded(TriangleNet.Topology.Otri@,TriangleNet.Topology.Osub@)">
            <summary>
            Check if given triangle is blinded by given segment.
            </summary>
            <param name="tri">Triangle.</param>
            <param name="seg">Segments</param>
            <returns>Returns true, if the triangle is blinded.</returns>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.BoundedVoronoiLegacy.SegmentsIntersect(TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point,TriangleNet.Geometry.Point@,System.Boolean)">
            <summary>
            Determines the intersection point of the line segment defined by points A and B with the 
            line segment defined by points C and D.
            </summary>
            <param name="seg">The first segment AB.</param>
            <param name="pc">Endpoint C of second segment.</param>
            <param name="pd">Endpoint D of second segment.</param>
            <param name="p">Reference to the intersection point.</param>
            <param name="strictIntersect">If false, pa and pb represent a line.</param>
            <returns>Returns true if the intersection point was found, and stores that point in X,Y.
            Returns false if there is no determinable intersection point, in which case X,Y will
            be unmodified.
            </returns>
        </member>
        <member name="T:TriangleNet.Voronoi.Legacy.IVoronoi">
            <summary>
            Voronoi diagram interface.
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.IVoronoi.Points">
            <summary>
            Gets the list of Voronoi vertices.
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.IVoronoi.Regions">
            <summary>
            Gets the list of Voronoi regions.
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.IVoronoi.Edges">
            <summary>
            Gets the list of edges.
            </summary>
        </member>
        <member name="T:TriangleNet.Voronoi.Legacy.SimpleVoronoi">
            <summary>
            The Voronoi Diagram is the dual of a pointset triangulation.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.SimpleVoronoi.#ctor(TriangleNet.Mesh)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Voronoi.Legacy.SimpleVoronoi" /> class.
            </summary>
            <param name="mesh"></param>
            <remarks>
            Be sure MakeVertexMap has been called (should always be the case).
            </remarks>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.SimpleVoronoi.Points">
            <summary>
            Gets the list of Voronoi vertices.
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.SimpleVoronoi.Regions">
            <summary>
            Gets the list of Voronoi regions.
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.SimpleVoronoi.Edges">
            <summary>
            Enumerates the edges of the Voronoi diagram.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.SimpleVoronoi.Generate">
             <summary>
             Generate the Voronoi diagram.
             </summary>
             <remarks>
             The Voronoi diagram is the geometric dual of the Delaunay triangulation.
             Hence, the Voronoi vertices are listed by traversing the Delaunay
             triangles, and the Voronoi edges are listed by traversing the Delaunay
             edges.
            </remarks>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.SimpleVoronoi.ConstructCell(TriangleNet.Voronoi.Legacy.VoronoiRegion)">
            <summary>
            Construct Voronoi region for given vertex.
            </summary>
            <param name="region"></param>
        </member>
        <member name="T:TriangleNet.Voronoi.Legacy.VoronoiRegion">
            <summary>
            Represents a region in the Voronoi diagram.
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.VoronoiRegion.ID">
            <summary>
            Gets the Voronoi region id (which is the same as the generators vertex id).
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.VoronoiRegion.Generator">
            <summary>
            Gets the Voronoi regions generator.
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.VoronoiRegion.Vertices">
            <summary>
            Gets the Voronoi vertices on the regions boundary.
            </summary>
        </member>
        <member name="P:TriangleNet.Voronoi.Legacy.VoronoiRegion.Bounded">
            <summary>
            Gets or sets whether the Voronoi region is bounded.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.Legacy.VoronoiRegion.GetNeighbor(TriangleNet.Geometry.Point)">
            <summary>
            Returns the neighbouring Voronoi region, that lies across the edge starting at
            given vertex.
            </summary>
            <param name="p">Vertex defining an edge of the region.</param>
            <returns>Neighbouring Voronoi region</returns>
            <remarks>
            The edge starting at p is well defined (vertices are ordered counterclockwise).
            </remarks>
        </member>
        <member name="T:TriangleNet.Voronoi.StandardVoronoi">
            <summary>
            Computing the standard Voronoi diagram of a Delaunay triangulation.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.StandardVoronoi.#ctor(TriangleNet.Mesh)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Voronoi.StandardVoronoi" /> class.
            </summary>
            <param name="mesh">The mesh.</param>
        </member>
        <member name="M:TriangleNet.Voronoi.StandardVoronoi.#ctor(TriangleNet.Mesh,TriangleNet.Geometry.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Voronoi.StandardVoronoi" /> class.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="box">The bounding box used to clip infinite Voronoi edges.</param>
        </member>
        <member name="M:TriangleNet.Voronoi.StandardVoronoi.#ctor(TriangleNet.Mesh,TriangleNet.Geometry.Rectangle,TriangleNet.Voronoi.IVoronoiFactory,TriangleNet.IPredicates)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Voronoi.StandardVoronoi" /> class.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="box">The bounding box used for clipping (not implemented.)</param>
            <param name="factory"></param>
            <param name="predicates"></param>
        </member>
        <member name="M:TriangleNet.Voronoi.StandardVoronoi.PostProcess(TriangleNet.Geometry.Rectangle)">
            <summary>
            Compute edge intersections with bounding box.
            </summary>
        </member>
        <member name="T:TriangleNet.Voronoi.VoronoiBase">
            <summary>
            The Voronoi diagram is the dual of a point set triangulation.
            </summary>
        </member>
        <member name="F:TriangleNet.Voronoi.VoronoiBase.predicates">
            <summary>Predicates</summary>
        </member>
        <member name="F:TriangleNet.Voronoi.VoronoiBase.factory">
            <summary>Voronoi factory</summary>
        </member>
        <member name="F:TriangleNet.Voronoi.VoronoiBase.rays">
            <summary>
            List of infinite half-edges, i.e. half-edges that start at circumcenters
            of triangles on the domain boundary.
            </summary>
        </member>
        <member name="M:TriangleNet.Voronoi.VoronoiBase.#ctor(TriangleNet.Mesh,TriangleNet.Voronoi.IVoronoiFactory,TriangleNet.IPredicates,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:TriangleNet.Voronoi.VoronoiBase" /> class.
            </summary>
            <param name="mesh">Triangle mesh.</param>
            <param name="factory">Voronoi object factory.</param>
            <param name="predicates">Geometric predicates implementation.</param>
            <param name="generate">If set to true, the constructor will call the Generate
            method, which builds the Voronoi diagram.</param>
        </member>
        <member name="M:TriangleNet.Voronoi.VoronoiBase.Generate(TriangleNet.Mesh)">
            <summary>
            Generate the Voronoi diagram from given triangle mesh..
            </summary>
            <param name="mesh"></param>
        </member>
        <member name="M:TriangleNet.Voronoi.VoronoiBase.ComputeVertices(TriangleNet.Mesh,TriangleNet.Topology.DCEL.Vertex[])">
            <summary>
            Compute the Voronoi vertices (the circumcenters of the triangles).
            </summary>
            <returns>An empty map, which will map all vertices to a list of leaving edges.</returns>
            <remarks>
            This method will also change triangle ids (to ensure linear numbering of triangles).
            </remarks>
        </member>
        <member name="M:TriangleNet.Voronoi.VoronoiBase.ComputeEdges(TriangleNet.Mesh,TriangleNet.Topology.DCEL.Vertex[],TriangleNet.Topology.DCEL.Face[],System.Collections.Generic.List{TriangleNet.Topology.DCEL.HalfEdge}[])">
            <summary>
            Compute the edges of the Voronoi diagram.
            </summary>
            <param name="mesh"></param>
            <param name="vertices"></param>
            <param name="faces"></param>
            <param name="map">Empty vertex map.</param>
        </member>
        <member name="M:TriangleNet.Voronoi.VoronoiBase.ConnectEdges(System.Collections.Generic.List{TriangleNet.Topology.DCEL.HalfEdge}[])">
            <summary>
            Connect all edges of the Voronoi diagram.
            </summary>
            <param name="map">Maps all vertices to a list of leaving edges.</param>
        </member>
        <member name="M:TriangleNet.Voronoi.VoronoiBase.EnumerateEdges">
            <inheritdoc />
        </member>
    </members>
</doc>
